[["index.html", "The Islamicate World 2.0: Studying Islamic Cultures through Computational Textual Analysis 1 Course Overview 1.1 Course summary 1.2 Virtual Classroom 1.3 Instructors 1.4 Required texts and technologies 1.5 Learning objectives 1.6 Expectations and grading procedures 1.7 Faculty-student communication 1.8 Emergency protocol 1.9 Course schedule 1.10 Course procedures and policies 1.11 Acknowledgements", " The Islamicate World 2.0: Studying Islamic Cultures through Computational Textual Analysis Jonathan Parkes Allen, Matthew Thomas Miller, Sarah Savant, Peter Verkinderen Spring 2021 Th 12:30pm - 3:00pm EST 1 Course Overview 1.1 Course summary The Islamicate World 2.0: Studying Islamic Cultures through Computational Textual Analysis is a Global Classrooms course that will be taught collaboratively by professors at the Roshan Institute for Persian Studies at the University of Maryland (College Park) and Aga Khan University (London). In this exciting, new project-based course, students from both institutions will come together to learn the basics of computational textual analysis while participating as student researchers in the nascent project of exploring the vast and largely unexplored tomes of textual data about the Islamicate world. It will also introduce students to theoretical and methodological debates in the field of global digital humanities. Like the digital humanities field that inspires its approach, it will be a highly interdisciplinary course that studies texts from multiple genres (lyric poetry to historical chronicles, legal treatises to the Quran) and languages (Arabic, Persian) with the aid of computational textual analysis tools. There are no language prerequisites, but it is preferable if students at least have elementary knowledge of either Arabic, Persian, Turkish, or Urdu. 1.2 Virtual Classroom This course will be conducted over Zoom. The Zoom link will be provided to you in the course email group. 1.3 Instructors 1.3.1 Dr. Jonathan Parkes Allen Office Hours: by appointment E-mail: jallen22@umd.edu Roshan Institute for Persian Studies University of Maryland, College Park Bio: Jonathan Parkes Allen is the Mellon Humanities Postdoctoral Fellow for the Open Islamicate Texts Initiative Arabic-script OCR Catalyst Project (OpenITI AOCP). He is a historian of early modern and medieval Islamicate history, with particular interests in the history of religious practice and thought in the Ottoman Empire as well as the application of digital methods to the study of global Islamicate history at scale. His current research focuses on Islamicate sainthood, devotion, and ritual, as well as the historical evolution of Arabic script and typography. Visit his website for more on his ongoing research interests. 1.3.2 Dr. Matthew Thomas Miller Office Hours: by appointment E-mail: mtmiller@umd.edu Roshan Institute for Persian Studies University of Maryland, College Park Bio: Matthew Thomas Miller, PhD. is Assistant Professor of Persian Literature and Digital Humanities at Roshan Institute for Persian Studies at the University of Maryland, College Park and and an affiliate of the Maryland Institute for Technology in the Humanities. He also serves as the Director of the Roshan Initiative in Persian Digital Humanities (PersDig@UMD) and as the co-PI for the multi-institutional Open Islamicate Texts Initiative (OpenITI) and the Persian Manuscript Initiative (PMI). He has received funding for these projects from The Andrew W. Mellon Foundation and The National Endowment for the Humanities. His research focuses on medieval Sufi literature, the history of sexuality and the body, and digital humanities. He currently is working on a book project, entitled Beautiful Bodies: Embodiment and Mystical Modes of Meaning Creation in Medieval Persian Sufi Literature, and a number of articles on computational or distant reading approaches to Persian literature and carnivalesque Sufi poetry. See his website for more details. 1.3.3 Dr. Sarah Bowen Savant Office Hours: by appointment E-mail: sarah.savant@aku.edu AKU ISMC, 10 Handyside Street, Kings Cross, London N1C 4DN Bio: At the AKU-ISMC, Professor Savant is a cultural historian working on the history and historiography of the Middle East and Iran up to 1400. She is the co-Principal Investigator, with Matthew Miller and Maxim Romanov, of the OpenITI, and the PI of the KITAB project, which focuses on Arabic book history using digital methods, especially text reuse detection. Her books include The New Muslims of Post-Conquest Iran: Tradition, Memory, and Conversion (Cambridge: Cambridge University Press, 2013) and The Excellence of the Arabs: A Translation of Ibn Qutaybahs Fal al-Arab wa l-tanbh al ulmih (with Peter Webb; The Library of Arabic Literature; Abu Dhabi: New York University Press, 2016) as well as articles and edited volumes on history writing, cultural memory, and the formation of identities. Her current book project - entitled A Cultural History of the Arabic Book - explores how the reuse of earlier texts helped to shape the historic tradition from its formative days onwards, as well as how authors conceived of their work and the very meaning of the book itself. 1.3.4 Dr. Peter Verkinderen Office Hours: by appointment E-mail: peter.verkinderen@aku.edu AKU ISMC, 10 Handyside Street, Kings Cross, London N1C 4DN Bio: Peter Verkinderen is a Post-doctoral Research Fellow at KITAB working on the central regions of the Islamic lands. He studied Classics and Arabic and Islamic studies at Ghent University. His PhD dissertation, also at Ghent University, was a reconstruction of the fluvial landscape of early Islamic Lower Mesopotamia, based on (mostly Arabic) texts, satellite imagery and data from archaeological and geological research. He has worked as the assistant director of the Netherlands-Flemish Institute in Cairo (2009-2014) and as a research fellow in the ERC project The Early Islamic Empire at Work (Hamburg University, 2014-2019), where he focussed on the position of Frs (SW Iran) in the early Islamic empire. His main research interests lie with the historical and geographical literature on the early Islamic empire. In recent years, the development of digital tools for historical and philological research has become one of his main interests. He is currently also involved in IslamAtlas, a research project aimed at the study and digital edition of the geographical texts and maps usually attributed to al-Iakhr and Ibn awqal. 1.4 Required texts and technologies Arnold, Taylor and Lauren Tilton. Humanities Data in R: Exploring Networks, Geospatial Data, Images, and Text. Springer International Publishing: 2015. ISBN: 9783319207018. Book website. Jockers, Matthew. Text Analysis with R for Students of Literature. Springer International Publishing: 2014. ISBN: 9783319031637. Book website. NB: These books are available through UMD libraries and in e-book format. Download R and R Studio (R is the actual programming language, while RStudio is a convenient interface for interacting with R; you need to download and install both  first R, then RStudio): https://cran.r-project.org/ https://www.rstudio.com/ NB: Students must have or be able to borrow a laptop for classwork. This course requires extensive use of a computer. 1.5 Learning objectives By the end of this course students will have: become acquainted with the major debates and tools in computational textual studies; developed intermediate-level skills in the R programming language; gained extensive experience working in international teams (termed collaboratories here) to solve complex problems; produced a mini-research publication that will be published on the course site (with the students permission). 1.6 Expectations and grading procedures The grade breakdown for this class is as follows (and see more details on each element in subsections below): 20% Participation 10% Co-discussion Leading 20% Class Assignments 40% Final (Group) Project 10% Class (Group) Presentation All grades will be posted on the course ELMS page. If you would like to review any of your grades, or have questions about how something was scored, please email me to schedule a time for us to meet and discuss. I am happy to discuss any of your grades with you, and if we have made a mistake we will immediately correct it. Any formal grade disputes must be submitted in writing and within one week of receiving the grade. Final letter grades are assigned based on the percentage of total assessment points earned. To be fair to everyone I have to establish clear standards and apply them consistently, so please understand that being close to a cutoff is not the same as making the cut (89.99  90.00). It would be unethical to make exceptions for some and not others. If you think you are very close to a cut-off point and would like the higher grade, please contact me about extra credit opportunities. 1.6.1 Final Grade Cutoffs + 97.00% + 87.00% + 77.00% + 67.00% + A 93.00% B 84.00% C 74.00% D 64.00% F &lt;60.0% - 90.00% - 80.00% - 70.00% - 60.00% - 1.6.2 Participation (20%) Students will be expected to come to class ready to discuss each text or technical training exercises in depth. Class participation is very important. However, please note, it is the quality of participation that We are interested innot quantity. Again, we cannot stress enough how important your regular attendance and active participation in class discussion is for your grade (for attendance policy, see #1 in the Course Procedures and Policies section below). If you have questions about your grade in this area, please visit me in office hours or schedule a time to come meet with me to discuss. 1.6.3 Co-discussion Leading (10%) You will be asked to serve as co-discussion leaders (alongside the instructors) on a rotating basis for the sessions in which we have specific assigned readings. You will be responsible for introducing and contextualizing the readings for the class and formulating class discussion questions based on the readings. 1.6.4 Class Assignments (20%) Beginning in the ninth week of the semester, you will be assigned specific assignments to complete in R. These assignments will be posted in ELMS and they must be turned in before class time in order to receive credit. 1.6.5 Final (Group) Project (40%) (and the Research Collaboratories) This course is a project-based learning course. The final project, therefore, will occupy a substantial amount of our class time throughout the semester and will be a major component of your final grade. But, fear not! The instructors will work closely with each of you and your groups to construct a collaborative research project. You will spend much of the second half of the course working on this project during class time with your fellow group members in the research collaboratory groups that we will form in week 11. At the conclusion of each research collaboratory session, each student will take on an assignment, which must be completed before the next class period. These will be reported to the instructors after class so they can keep track of each individuals contributions to the project and grade them on these weekly assignments. These tasks will vary greatly on the basis of each groups project: some students may be working on cleaning and/or reformatting texts, others on developing a R script, and still others may be tasked with doing traditional humanities research in order to properly contextualize the results of the groups new computational textual analysis. We do not expect that you will have all of the answers when you begin work on your final project. You will need to play and experiment with the texts and different modes of textual analysis and visualization available to you in R, and you certainly will hit dead ends and completely fail (productively) at times too. In this process, however, you will learn a great deal, as the research on experiential and problem/project-based learning has shown. We will guide you throughout your work on the final project, making sure that it eventually comes together to form a micro-publication by the end of the course. You will present on and submit your final projects on the assigned exam day for this course, May 18th by 6:00pm. 1.6.6 Class presentation (10%) Your class presentation is an opportunity for you to present your groups final project to the class. It should be between 20-30 minutes in length. You should provide an overview of your initial hypothesis, methods of analysis, problems you encountered in your research, and your research findings (including, how they corroborate or problematize the existing scholarly narratives). You will be graded on the quality of both your research and presentation of it. You will present on your final project sometime around May 18th (we will mutually determine a time for class presentations based on everyones availability and timezone restrictions). 1.7 Faculty-student communication Faculty and advisors use email to convey important information. Students are responsible for keeping their email address up to date. Failure to check email or errors in forwarding are the responsibility of the student, and do not constitute an excuse for missing announcements or deadlines. For better or for worse, in the modern digital world, it is a necessity that you check your email at least a few times per day (during regular work hours) and respond promptly to messages. I would suggest checking messages in the morning and late afternoon at the minimum. 1.8 Emergency protocol This course will be conducted via Zoom. 1.9 Course schedule 1.9.1 Week 1: Class Introduction and Introduction to Computational Textual Analysis 1/28/2021 Thursday [NB: Keep in mind that dates below are given according to the American convention: Month/Day/Year] Prepare for Class: Underwood, Ted. Theorizing Research Practices We Forgot to Theorize Twenty Years Ago. Representations 127, no. 1 (Summer 2014): 6472. [Course Google Drive] Ramsay, Stephen. Reading Machines: Toward an Algorithmic Criticism. Champaign, IL: University of Illinois Press, 2011. 1-17. [Course Google Drive] Underwood, Ted. A Genealogy of Distant Reading. DHQ 11 (2017): http://www.digitalhumanities.org/dhq/vol/11/2/000317/000317.html 1.9.2 Week 2: Corpus Construction and Modeling Digital Humanities Data 2/4/2021 Thursday Prepare for Class: Flanders, Julia and Fotis Jannidis. Data Modeling in a Digital Humanities Context. In The Shape of Data in the Digital Humanities: Modeling Texts and Text-based Resources, edited by Julia Flanders and Fotis Jannidis, 3-25. New York: Rotuledge, 2019. [Course Google Drive] Underwood, Ted. Algorithmic Modeling: Or, Modeling Data We Do Not Yet Understand. In The Shape of Data in the Digital Humanities: Modeling Texts and Text-based Resources, edited by Julia Flanders and Fotis Jannidis, 250-263. New York: Rotuledge, 2019. [Course Google Drive] Martin Weisser. Understanding Corpus Design. In Practical Corpus Linguistics: An Introduction to CorpusBased Language Analysis, edited by Martin Weisser, 29-42. London: Wiley (2015). [Course Google Drive] Watch eScriptorium training video #1, Introduction to eScriptorium. In class: Weekly reading report. Collaboratory assignment on digital text production (bring your computers!). 1.9.3 Week 3: Corpus Construction and Computational Textual Analysis in Islamicate Studies 2/11/2021 Thursday Prepare for Class: Savant, Sarah Bowen. The History of Arabic books in the digital age. British Academy Review Summer 2016: 42-45. [Course Google Drive] Romanov, Maxim. Toward Abstract Models for Islamic History. In The Digital Humanities + Islamic Middle Eastern Studies, edited by Elias Muhanna, 117149. Berlin: De Gruyter, 2016. [Course Google Drive] Bulliet, Richard. Conversion to Islam in the Medieval Period. Cambridge: Harvard University Press, 1979, 1-32. Watch eScriptorium training video #2, Best Practices for Training Data Production. Upload and OCR a test text. In class: Weekly reading report. Collaboratory assignment on digital text production (bring your computers!). 1.9.4 Week 4: Corpus Construction and Latest Approaches to Computational Textual Analysis I 2/18/2021 Thursday Prepare for Class: Underwood, Ted. Distant Horizons: Digital Evidence and Literary Change. Chicago: University of Chicago Press, 2019. (selections). [Course Google Drive] Watch eScriptorium training video #3, Advanced Functionalities in eScriptorium. Watch eScriptorium training video #4, Data Export. Produce five pages of training data on your text and submit (after watching video #4). In class: Weekly reading report. Collaboratory assignment on digital text production (bring your computers!). 1.9.5 Week 5: Corpus Construction and Latest Approaches to Computational Textual Analysis II 2/25/2021 Thursday Prepare for Class: Piper, Andrew. Enumerations: Data and Literary Study. Chicago: University of Chicago Press, 2018. (selections). [Course Google Drive] Watch eScriptorium training video #5, Training Your own Models in eScriptorim. Re-OCR your new transcription and segmentation models. In class: Weekly reading report. Collaboratory assignment on digital text production (bring your computers!). 1.9.6 week 6: Interacting with the OpenITI Corpus Using Github and EditPad 3/4/2021 Thursday Prepare for Class: Introduction to the command line! Go here: http://programminghistorian.org/lessons/intro-to-bash A more detailed introduction (and useful list of commands) is available here: https://learnpythonthehardway.org/book/appendixa.html Introduction to using Github: https://guides.github.com/activities/hello-world/ Introduction to Github from command line: https://towardsdatascience.com/getting-started-with-git-and-github-6fcd0f2d4ac6 Raising an Issue in Github Watch video, Interacting with the OpenITI Corpus through Github. Watch video, Introduction to Working with Texts in OpenITI EditPad Pro. Watch video, Introduction to OpenITI mARkdown. Do Github pull/edit/push activity (link) In class: Weekly reading report. OpenITI mARkdown bootcamp! 1.9.7 week 7: Using Regex on Texts 3/11/2021 Thursday Prepare for Class: Regex tutorials #1-16: Regexone.com In class: Weekly reading report. Regex workshop. Introduction to R and R installation: https://cran.r-project.org/ and https://www.rstudio.com/ (bring your computers!) 3/14/2021 - 3/21/2021: UMD Spring Break (No class) 1.9.8 week 8: Introducing R (in GUI) through Stylo(metry) 3/25/2021 Thursday Prepare for Class: Holmes, David I. The Evolution of Stylometry in Humanities Scholarship. Literary &amp; Linguistic Computing 13, no. 3 (1998): 111-117. [Course Google Drive] Koppel, M., Schler, J. and Argamon, S. Computational Methods in Authorship Attribution. Journal of the American Society for Information Science and Technology 60, no. 1 (2009): 9-26. [Course Google Drive] Eder, Maciej, Jan Rybicki, and Mike Kestemont. Stylometry with RA Package for Computational Text Analysis. The R Journal Vol. 8/1 (2016). [Course Google Drive] Eder, Maciej, and Jan Rybicki. STYLO R Script Mini HOW TO. [Course Google Drive] Optional (extra credit for UMD students): Sadeghi, Behnam. The Chronology of the Qurn: A Stylometric Research Program. Arabica 58.34 (2011): 210-99. [ELMS] In class: Weekly reading report. Collaboratory assignment with Stylo R Package (bring your computers!). 1.9.9 week 9: R Bootcamp I 4/1/2021 Thursday Prepare for Class: Chapter 1-2 in Arnold and Tilton and Chapter 1 in Jockers (there will be some overlap). Submit Before Class: Practice exercises for chapter 2 in Arnold &amp; Tilton, pages 183-186 (Please submit your code (i.e., the R script file) and also any resulting visualizations (e.g., graphs, tables) or answers (in the form of a screenshot)). In class: Weekly Reading Report: Analyzing Text Reuse Data in R (Sarah Bowen Savant). Sheykh Google activity (bring your computers!). 1.9.10 week 10: R Bootcamp II 4/8/2021 Thursday Prepare for Class: Chapter 3 in Arnold and Tilton. Submit Before Class: Practice exercises for chapter 3 in Arnold &amp; Tilton, pages 186-188. In class: Weekly Reading Report: Topic Modeling in R (Matthew Thomas Miller). First brainstorming session on final project topics. 1.9.11 week 11: R Bootcamp III 4/15/2021 Thursday Prepare for Class: Chapter 4 in Arnold and Tilton. Submit Before Class: Practice exercises for chapter 4 in Arnold &amp; Tilton, pages 188-190. In class: Weekly Reading Report: Geolocation Analysis in R (Peter Verkinderen). Second brainstorming session on final project topics (by end of this class, we will set the text analysis groups and their respective assigned chapters for week 10 based your initial ideas for the final project). Research collaboratory groups finalized and first set of individualized assignments distributed in preparation for your research groups first research collaboratory. 1.9.12 week 12: Research Collaboratory I 4/22/2021 Thursday: Research Collaboratory Prepare for Class: Task(s) assigned to you by your research group in previous collaboratory. In class: Research collaboratory focused on final project (bring your computers!). 1.9.13 week 13: Research Collaboratory II 4/29/2021 Thursday: Research Collaboratory Prepare for Class: Task(s) assigned to you by your research group in previous collaboratory. Submit Before Class: By todays class, all groups need to submit a final project proposal to the instructors. This proposal should include three parts: a 1-page overview of the topic on which you are proposing to work; a timeline for the completion of each phase of the work (which the instructors will need to approve); and a detailed list of tasks for which each group member will be responsible. After you have submitted these, the instructors will review them together and send you our feedback, recommendations, and expectations for your final project. In class: Research collaboratory focused on final project (bring your computers!). 1.9.14 week 14: Research Collaboratory III 5/6/2021 Thursday: Research Collaboratory Prepare for Class: Task(s) assigned to you by your research group in previous collaboratory. In class: Research collaboratory focused on final project (bring your computers!). Last Day of Classes: Tuesday, May 11th 2021 Reading Day: Wednesday, May 12th 2021 1.9.15 Final Exam Tuesday, May 18th 4:00-6:00 pm (Present final project and submit final version of final project) 1.10 Course procedures and policies For full list of campus policies, please see: https://www.ugst.umd.edu/courserelatedpolicies.html Below are some important policies related to this course: 1.10.1 Attendance and Absences*: Students are expected to attend classes regularly. Consistent attendance offers students the most effective opportunity to gain command of course concepts and materials. Students who miss class without an excused absence will receive a 0% for that days participation grade. Events that justify an excused absence include: religious observances; mandatory military obligation; illness of the student or illness of an immediate family member; participation in university activities at the request of university authorities; and compelling circumstances beyond the students control (e.g., death in the family, required court appearance). Absences stemming from work duties other than military obligation (e.g., unexpected changes in shift assignments) and traffic/transit problems do not typically qualify for excused absence. Students claiming an excused absence must notify the course instructor in a timely manner and provide appropriate documentation. The notification should be provided either prior to the absence or as soon afterwards as possible. In the case of religious observances, athletic events, and planned absences known at the beginning of the semester, the student must inform the instructor during the schedule adjustment period. All other absences must be reported as soon as is practical. The student must provide appropriate documentation of the absence. The documentation must be provided in writing to the instructor. The full university attendance/absence policy can be found here. * As long as COVID-19 persists, we will be willing to make exceptions to these general rules on a case-by-case basis. Please discuss with me concerns you have about attendance and we can develop alternative plans, if necessary. 1.10.2 Academic Integrity: The Universitys Code of Academic Integrity is designed to ensure that the principles of academic honesty and integrity are upheld. In accordance with this code, academic dishonesty will not be tolerated. Please ensure that you fully understand this code and its implications because all acts of academic dishonesty will be dealt with in accordance with the provisions of this code. All students are expected to adhere to this Code. It is your responsibility to read it and know what it says, so you can start your professional life on the right path. It is important to note that course assistance websites, such as CourseHero, are not permitted sources, unless the instructor explicitly gives permission for you to use one of these sites. Material taken or copied from these sites can be deemed unauthorized material and a violation of academic integrity. These sites offer information that might not be accurate and that shortcut the learning process, particularly the critical thinking steps necessary for college-level assignments. Additionally, it is understandable that students may use a variety of online or virtual forums for course-wide discussion (e.g., GroupME or WeChat). Collaboration in this way regarding concepts discussed in this course is permissible. However, collaboration on graded assignments is strictly prohibited unless otherwise stated. Examples of prohibited collaboration include: asking classmates for answers on quizzes or exams, asking for access codes to clicker polls, etc. Finally, on each exam or assignment you must write out and sign the following pledge: I pledge on my honor that I have not given or received any unauthorized assistance on this exam/assignment. Please visit the Office of Undergraduate Studies full list of campus-wide policies and follow up with me if you have questions. 1.10.3 Accessibility and Disability Support: The University of Maryland is committed to creating and maintaining a welcoming and inclusive educational, working, and living environment for people of all abilities. The University of Maryland is also committed to the principle that no qualified individual with a disability shall, on the basis of disability, be excluded from participation in or be denied the benefits of the services, programs, or activities of the University, or be subjected to discrimination. The Accessibility &amp; Disability Service (ADS) provides reasonable accommodations to qualified individuals to provide equal access to services, programs and activities. ADS cannot assist retroactively, so it is generally best to request accommodations several weeks before the semester begins or as soon as a disability becomes known. Any student who needs accommodations should contact me as soon as possible so that I have sufficient time to make arrangements. For assistance in obtaining an accommodation, contact Accessibility and Disability Service at 301-314-7682, or email them at adsfrontdesk@umd.edu. Information about sharing your accommodations with instructors, note taking assistance and more is available from the Counseling Center. 1.10.4 Copyright Notice: Class lectures and other materials are protected by a Creative Commons Attribution-NonCommercial-ShareAlike (CC BY-NC-SA) license. Copyright infringements may be referred to the Office of Student Conduct. 1.10.5 Academic Accommodations for Students Who Experience Sexual Misconduct: The University of Maryland is committed to providing support and resources, including academic accommodations, for students who experience sexual or relationship violence as defined by the Universitys Sexual Misconduct Policy. To report an incident and/or obtain an academic accommodation, contact the Office of Civil Rights and Sexual Misconduct at 301-405-1142. If you wish to speak confidentially, contact Campus Advocates Respond and Educate (CARE) to Stop Violence at 301-741-3555. As responsible university employees faculty are mandatory reporters and are required to report any disclosure of sexual misconduct, i.e., they may not hold such disclosures in confidence. More information can be found here. 1.10.6 Diversity: The University of Maryland values the diversity of its student body. Along with the University, the instructor(s) are committed to providing a classroom atmosphere that encourages the equitable participation of all students regardless of age, disability, ethnicity, gender, national origin, race, religion, or sexual orientation. Potential devaluation of students in the classroom that can occur by reference to demeaning stereotypes of any group and/or overlooking the contributions of a particular group to the topic under discussion is inappropriate and will not be tolerated. 1.10.7 Faculty-Student Communication: Faculty and advisors use email and ELMS to convey important information, and students are responsible for keeping their email address up to date, and must ensure that forwarding to another address functions properly. Failure to check email, errors in forwarding, and returned email are the responsibility of the student, and do not constitute an excuse for missing announcements or deadlines. In the modern digital world, it is a necessity that students check email and other forms of digital communication (e.g., ELMS) at least a few times per day and respond promptly to messages. I would suggest checking messages in the morning and evening at the minimum. 1.10.8 Emergency Protocol: This course is conducted via Zoom. 1.10.9 Forms of Address (Names and Pronouns) and Self-Identification: Our institutions official policy states that The University of Maryland recognizes that name and gender identity are central to most individuals sense of self and well-being, and that it is important for the University to establish mechanisms to acknowledge and support individuals self-identification. One way we can support self-identification is by honoring the name and pronouns that each of us go by. Many people (e.g. international students, performers/writers, trans people, and others) might go by a name in daily life that is different from their legal name. In this classroom, we seek to refer to people by the names that they go by. Pronouns can be a way to affirm someones gender identity, but they can also be unrelated to a persons identity. They are simply a public way in which people are referred to in place of their name (e.g., he or she or they or ze or something else). In this classroom, you are invited (if you want to) to share what pronouns you go by, and we seek to refer to people using the pronouns that they share. The pronouns someone indicates are not necessarily indicative of their gender identity. Visit please visit the following links to learn more about gender identity and pronouns: https://lgbt.umd.edu/rainbow-terrapin-network-transterps and https://lgbt.umd.edu/good-practices-names-and-pronouns. Additionally, I would like to emphasize that how you identify in terms of your gender, race, class, sexuality, religion, and dis/ability, among all aspects of your identity, is your choice whether to disclose (e.g., should it come up in classroom conversation about our experiences and perspectives) and should be self-identified, not presumed or imposed. I will do my best to address and refer to all students accordingly and will support you in doing so as well. 1.10.10 Statement in Support of Students with Children: We welcome and support students who are parents. We appreciate that parenthood presents unique challenges and demands on a students time and availability. If childcare constraints present an issue with class attendance, we invite student parents to work with us to discuss alternate arrangements. We also welcome and support pregnant students and will provide possible accommodations and discuss arrangements so that students can complete course requirements. 1.10.11 Communication with Peers: With a diversity of perspectives and experience, we may find ourselves in disagreement and/or debate with one another. As such, it is important that we agree to conduct ourselves in a professional manner and that we work together to foster and preserve a virtual classroom environment in which we can respectfully discuss and deliberate controversial questions. We encourage you to confidently exercise your right to free speechbearing in mind, of course, that you will be expected to craft and defend arguments that support your position. Keep in mind, that free speech has its limit and this course is NOT the space for hate speech, harassment, and derogatory language. We will make every reasonable attempt to create an atmosphere in which each student feels comfortable voicing their argument without fear of being personally attacked, mocked, demeaned, or devalued. Any behavior (including harassment, sexual harassment, and racially and/or culturally derogatory language) that threatens this atmosphere will not be tolerated. Please alert us immediately if you feel threatened, dismissed, or silenced at any point during our semester together and/or if your engagement in discussion has been in some way hindered by the learning environment. 1.10.12 Student Resources and Academic Services: Taking personal responsibility for you own learning means acknowledging when your performance does not match your goals and doing something about it. We hope you will come talk to me so that we can help you find the right approach to success in this course, and we encourage you to visit UMDs Student Academic Support Services website to learn more about the wide range of campus resources available to you. In particular, everyone can use some help sharpen their communication skills (and improving their grade) by visiting UMDs Writing Center and schedule an appointment with the campus Writing Center. You should also know there are a wide range of resources to support you with whatever you might need (UMDs Student Resources and Services website may help). If you feel it would be helpful to have someone to talk to, visit UMDs Counseling Center or one of the many other mental health resources on campus. 1.10.13 Basic Needs Security: Any student who has difficulty affording groceries or accessing sufficient food to eat every day, or who lacks a safe and stable place to live, and believes this may affect their performance in this course, is encouraged to use the resources listed below for support and visit UMDs Division of Student Affairs website for more information. Students are better served and supported when such circumstances are shared with the professor. Please consider sharing your situation with your professor who may be able to assist you in finding the appropriate resources. Campus Pantry: Alleviates food insecurity and provides a safe space to distribute emergency food to current UMD students. The Campus Pantry is located in the Health Center, Heilsa Room 0143 (Ground Floor), and is open each Friday during the semester from 9 a.m. - 5 p.m. Individual appointments are also available. Contact 301.314.8054 or campuspantry@umd.edu. More information is available at http://campuspantry.umd.edu/. Fostering Terp Success: Provides a safe and supportive campus network for students who were or are in foster care, who are homeless or at risk of being homeless, and who are without a supportive family system. Contact 301.314.8440 or fosteringterpsuccess@umd.edu. More information is available at [www.studentaffairs.umd.edu/fostering-terp-success)(www.studentaffairs.umd.edu/fostering-terp-success). Counseling &amp; Mental Health Services: Counseling Center: Shoemaker Building, 301.314.7651, www.counseling.umd.edu Mental Health Service (University Health Center): Campus Drive, 301.314.8106, http://www.health.umd.edu/mentalhealth/services University Chaplains: University Chapel, 301.314.9866, http://thestamp.umd.edu/engagement/memorial_chapel/chaplains Student Crisis Fund: For students who have an unexpected critical situation and need immediate financial support. Students will be asked for basic information to describe their circumstances of the emergency need and what other sources of funds are available. For more information, visit http://www.crisisfund.umd.edu/gethelp.html 1.10.14 Technology Policy: Please refrain from using cellphones, laptops, and other electronic devices during class sessions unless we have designated such use as part of a class exercise. 1.11 Acknowledgements This course is a Global Classrooms course, taught by staff at the University of Maryland, College Park (UMD) and the Institute for Muslim Civilizations at Aga Khan University, London. It is based on their research, which has received funding from the European Research Council (ERC) under the European Unions Horizon 2020 research and innovation programme (Grant agreement No. 772989), The Andrew W. Mellon Foundation, the University of Maryland, and Aga Khan University. "],["week-1-class-introduction-and-introduction-to-computational-textual-analysis-in-the-humanities.html", "2 Week 1: Class Introduction and Introduction to Computational Textual Analysis in the Humanities", " 2 Week 1: Class Introduction and Introduction to Computational Textual Analysis in the Humanities 1/28/2021 Thursday [NB: Keep in mind that dates below are given according to the American convention: Month/Day/Year] Prepare for Class: Underwood, Ted. Theorizing Research Practices We Forgot to Theorize Twenty Years Ago. Representations 127, no. 1 (Summer 2014): 6472. [Course Google Drive] Ramsay, Stephen. Reading Machines: Toward an Algorithmic Criticism. Champaign, IL: University of Illinois Press, 2011. 1-17. [Course Google Drive] Underwood, Ted. A Genealogy of Distant Reading. DHQ 11 (2017): http://www.digitalhumanities.org/dhq/vol/11/2/000317/000317.html "],["week-2-corpus-construction-and-modeling-digital-humanities-data-1.html", "3 Week 2: Corpus Construction and Modeling Digital Humanities Data 3.1 most recent OCR transcription model for eScriptorium 3.2 where do I find eScriptorium? 3.3 Getting started with eScriptorium 0.6.9", " 3 Week 2: Corpus Construction and Modeling Digital Humanities Data 2/4/2021 Thursday Prepare for Class: Flanders, Julia and Fotis Jannidis. Data Modeling in a Digital Humanities Context. In The Shape of Data in the Digital Humanities: Modeling Texts and Text-based Resources, edited by Julia Flanders and Fotis Jannidis, 3-25. New York: Routledge, 2019. [Course Google Drive] Underwood, Ted. Algorithmic Modeling: Or, Modeling Data We Do Not Yet Understand. In The Shape of Data in the Digital Humanities: Modeling Texts and Text-based Resources, edited by Julia Flanders and Fotis Jannidis, 250-263. New York: Routledge, 2019. [Course Google Drive] Martin Weisser. Understanding Corpus Design. In Practical Corpus Linguistics: An Introduction to CorpusBased Language Analysis, edited by Martin Weisser, 29-42. London: Wiley (2015). [Course Google Drive] Watch eScriptorium training video #1, Introduction to eScriptorium.: https://www.youtube.com/watch?v=N0hSNC3YvD4 In class: Weekly reading report. Collaboratory assignment on digital text production (bring your computers!). 3.1 most recent OCR transcription model for eScriptorium Download it here 3.2 where do I find eScriptorium? The UMD instance of eScriptorium can be found here: http://simorgh.umd.edu:8080/ 3.3 Getting started with eScriptorium 0.6.9 Tutorial written by Alix Chague, and translated by Jonathan Allen. 3.3.1 Additional Documentation: Video demo of part of the eScriptorium features: https://escripta.hypotheses.org/escriptorium-video-gallery Source code of eScriptorium: https://gitlab.inria.fr/scripta/escriptorium 3.3.2 Prerequisites: Secure an account on an eScriptorium instance; Or install a local instance of eScriptorium ( with Docker or without Docker ). 3.3.3 Summary Step by step 1.1. Connection to eScriptorium 1.2. Create a new document 1.2.1. Point terminology 1.2.2. Instructions 1.3. Upload images 1.3.1. Access the interface 1.3.2. Import local files 1.3.3. Import images from PDF file 1.3.4. Use an IIIF manifesto 1.4. Manually annotate documents 1.4.1. Access the interface 1.4.2. Annotate segments and areas on the image 1.4.3. Annotate the transcript 1.4.4. Apart√© on the articulation of baselines , polygons and transcriptions 1.4.5. Change the order of segments 1.4.6. Semantic annotation 1.5. Import annotations 1.5.1. Import structured annotations in XML 1.5.2. Import annotations from plain text 1.6. Automatically annotate documents 1.6.1. Instructions 1.6.2. Setting up segmentation 1.7. Train models 1.8. Export data Manage a collaborative annotation campaign 2.1. Create a user group 2.2. Share a document with another user or with a group 2.3. Share a template with another user or with a group 3.3.4 1. Step by step 3.3.4.1 1.1. Logging into eScriptorium You log into eScriptorium with an individual account made up of a login, a password and an email address. An account is created by the user after receiving an invitation or by the site administrator: Overview of the connection interface, where you enter your login and password before clicking on \"login\". Login form Once logged on, you will see the dashboard which allows you to manage all the documents created by and shared with the account. On first login, this dashboard is empty: Dashboard preview, empty 3.3.4.2 1.2. Create a new document 3.3.4.2.1 1.2.1. Point terminology A \"document\" is a collection of images forming a whole unit; A \" document-part\" is an image--a page belonging to a document. 3.3.4.2.2 1.2.2. Instructions To create a document, click on the Create new button; a new page is displayed as well as an input form: Document description tab The document \"description\" tab is where you fill in the metadata. The \"Name\" field is mandatory. The others are optional and can be completed later. We will come back to the Ontology section later. Once the information has been entered, click on Create to create the document; a message is then displayed: \"Document created successfully!\" You can still modify the data entered: the \"Create\" button has been replaced by an \"Update\" button. Access the document editing interface from the dashboard. To return to this form from the dashboard, click on the Edit icon in front of the document. 3.3.4.3 1.3. Upload images 3.3.4.3.1 1.3.1. Access the interface The Images interface is used to manage most of the tasks related to automatic image processing and imports and exports. To access the image loading interface, click on the Images tab. Navigation between the \"Description\" and \"Images\" tabs. There are several ways to import images to the platform. 3.3.4.3.2 1.3.2. Import local files Simply load the files using drag-and-drop or click in the box to open the file explorer. Note: you must wait until all the images are loaded before refreshing the page! How to import images from the local file system. 3.3.4.3.3 1.3.3. Import images from PDF file Click on the Import button, then Images (PDF) option to load a PDF file and automatically extract the images. Please note, only the images are imported. If the PDF contains a text layer corresponding to the transcription, it is not imported. demonstration of importing images from a PDF 3.3.4.3.4 1.3.4. Use an IIIF manifesto Click on the Import button, then the Images (IIIF) option, then enter the url of an IIIF manifesto. All the images associated with the manifesto are then copied locally, as well as the metadata, which is visible in the Description tab. Example: https://gallica.bnf.fr/iiif/ark:/12148/btv1b53026595r/manifest.json Demonstration of importing images through an IIIF manifesto. 3.3.4.4 1.4. Manually annotate documents 3.3.4.4.1 1.4.1. Access the interface Manual annotation is necessary to generate ground truth data used to train models, or to correct the result of these operations. It can also be used as part of an annotation campaign that does not make use of Kraken models (eScriptorium only serves as an input environment). The document-parts edit tab allows you to create or modify annotation elements manually. It is accessed by clicking on the Edit tab at the top of the page or by clicking on the Edit button on each map representing a part-document. There are several viewing panes in this tab corresponding to each possible editing task. Several visualization panes can be activated within the \"Edit\" tab Click on the \"Edit\" button on each card representing a part-document Another way to access the \"Edit\" tab \"Image source\" allows you to display the source image; Segmentation displays the segmentation editing pane; \"Transcription\" displays the editing pane of the transcription in diplomatic view; \"Text\" is used to display the editing pane of the transcription in text mode. Enabling and disabling edit panes 3.3.4.4.2 1.4.2. Annotate segments and areas on the image The segment editing pane allows you to perform several essential operations: Drawing baselines corresponding to the locations of the text on the image in two ways: Free route (not recommended); Point by point plot. Adding points on a line (select it then double-click at the point's location); Moving one or more point (s) by a simple select-drag; Deleting one or more point (s) on a line; Cutting one or more lines using the scissors tool; Joining one or more lines; Configuring the reading direction of a line; Activating the calculation of the polygons associated with each line (this task is automatic and managed asynchronously without any action on the part of the user after the first use). In this pane, it is also possible to create regions (or zones ) and associate segments to them. A segment located within the perimeter of a region is therefore not automatically associated with it. All the operations that can be carried out in this pane are detailed in a help window (to display it, click on \"?\"). It will thus be noted that there are many shortcuts making it possible to simplify all these operations. 3.3.4.4.3 1.4.3. Annotate the transcript Only when there are segments and masks on the image is it possible to use the functionalities of the Transcription and Text tabs. To add or modify a transcription associated with a segment from the Transcription pane, click on the corresponding zone. An input window is displayed. To record a transcription, press Enter: the transcription interface automatically displays the input field for the next segment. As you type in the Transcription pane, the crenellated areas are replaced by text and the content of the Text pane changes. It is therefore also possible to modify the text from the Text pane and even to copy and paste several lines at once. Manually edit the transcription from the \"Transcription\" pane. 3.3.4.4.4 1.4.4. A note on the articulation of baselines, polygons and transcriptions** The baseline is the central element for storing information in the eScriptorium database. So : It is possible to modify a baseline (remove / move / add points) without impacting the transcription; The polygon is always calculated from the baseline, including during training It is possible to modify the polygon manually (not recommended) without this impacting the transcription. During the training of the Kraken models, the calculation of the polygons is reset: the user therefore has an interest in not intervening on the polygons and on the contrary to ensure that the baselines are drawn in such a way that the automatically generated polygons are correct. . Moreover, when manually entering ground truth data, care should be taken to transcribe only what is inside the polygon. 3.3.4.4.5 1.4.5. Changing the order of segments The playback order of the segments is calculated automatically. You can display the order number of each segment from the Segmentation pane by clicking on Toggle ordering display (L) or from the Text pane where the lines are displayed in the following order. It is possible to modify this order from the Text pane by clicking Toggle sorting mode. A simple drag and drop of the lines is then enough to carry out the modification. Note: it is advisable to ensure the quality of the segmentation before changing the order of the lines because adding or deleting lines systematically restarts the calculation of this order, overwriting manual modifications in the process. Edit the order of the segments from the Text pane 3.3.4.4.6 1.4.6. Semantic annotation It is possible to associate labels (or tags ) with segments and regions by following an ontology pre-defined by the user from the Description tab. There are default tags , but it is possible to add some using the input fields (click on \"+\" then \"Update\" to add the new tag to the list) or to delete (uncheck the box in front of the tag then click on \"Update\"). From the Segmentation pane, select an area or a segment, then click on Set the type on all selected lines / regions (T) and choose the appropriate tag . The color of the area or line changes. It is possible to apply a tag to several regions or segments at once: all you have to do is select several (Ctrl + click-drag or keep Ctrl pressed and click the targeted segments / regions). Add elements in the ontology from the \"Description\" pane then apply the tags to the segments / regions from the \"Edit\" pane. 3.3.4.5 1.5. Import annotations 3.3.4.5.1 1.5.1. Import structured annotations in XML It is possible to import segments and / or a transcript generated outside of eScriptorium. To do this, in the Images tab, click on the Import / Transcription (XML) option. A form appears allowing you to specify a name to identify the version to import and to load the file to import. This can be an ALTO XML file, a PAGE XML file or a ZIP containing several ALTO or PAGE XML files. It is not necessary to select beforehand which document-parts are concerned by the import: the link is made automatically according to the information contained in the XML files. Form for configuring segmentation and / or transcription imports Please note, after importing segments generated without Kraken / eScriptorium, it is essential to reset the polygons ( masks ) before using these documents to train a transcription model. 3.3.4.5.2 1.5.2. Import annotations from plain text It is possible to manually import a transcription from a plain text version using the Text pane of the Edit tab. Each line break then indicates the passage to a new segment. It is therefore necessary to ensure that the reading order of the lines matches. 3.3.4.6 1.6. Automatically annotate documents 3.3.4.6.1 1.6.1. Instructions Automatic document annotation is managed from the Images tab. Select the images to annotate; Click on Segment (for the detection of baselines, polygons and / or areas) or on Transcribe (for transcription); A form is displayed: it allows you to load a Kraken model or to use a model already available in eScriptorium and, for segmentation, to configure the annotation. 3.3.4.6.2 1.6.2. Setting up segmentation \"Segmentation steps\" allows you to manage what level of segmentation is carried out: Line and Regions leads to the generation of zones (provided that the model used has been trained for this), baselines and associated polygons. Line Baselines and Masks leads to the generation of baselines and associated polygons. \"Only line Masks\" does not require loading a model; this option allows you to reset on the fly the calculation of the polygons associated with the baselines already present on the images. Regions makes it possible to keep intact the baselines and polygons already present on the images and to generate only the zones. \"Text direction\" is used to indicate the reading direction of the lines. Overview of the options available in the automatic segmentation configuration form. 3.3.4.7 1.7. Train models 3.3.4.7.1 1.7.1. Start a workout Training of Kraken models is started from the Images tab; it is tracked from the Models tab (inactive as long as no model other than the default model is associated with the document). Access to training functions may be subject to authorization. It is managed from the administration interface. To train a model, all the mobilized images / annotations must be in the same document. Select the share documents containing the ground truth; Click on \"Train\" then select the type of model to train: \"Segment\" for a segmentation model, \"Recognizer\" for a transcription model; Fill out the form then click on \"Train\"; The training task is started, sometimes you have to wait before this is displayed. When the training is finished, the user receives a notification and can access the final model from the Models tab. It is then possible to download the model or use it on the document. 3.3.4.7.2 1.7.2. Refine a model or start from scratch? The training configuration form allows you to choose: If you want to start from scratch (simply indicate the name to give to the new model that will be created); Or if you want to refine a model (it can be loaded from the file manager, or be already present in the list of models associated with the current document). Caution: in version 0.6.9, modifying the name of the model to train is only taken into account in the case of a model starting from zero. In order not to overwrite an already existing model, make sure to download the model locally, rename it according to the name desired for the new model, then load it into eScriptorium from the form. 3.3.4.8 1.8. Export annotations The export of annotations is carried out from the Images tab. Select the relevant part-documents; Click on \"Export\" then fill out the form: Specify the version of the transcription to export; Specify the export format (\"Alto\" for XML ALTO, \"Pagexml\" for XML PAGE, or \"Text\" for plain text); Check \"Include Images\" if you also want to export the images; Click on Export and save the generated ZIP file. 3.3.5 2. Manage a collaborative annotation campaign 3.3.5.1 2.1. Create a user group (admin) It is possible to create user groups from the administrator's dashboard (provided you have the associated rights). These groups are used to define work teams or to assign certain rights to a set of users. It will soon be possible for a user with sufficient rights to create a team and invite other users to it. 3.3.5.2 2.2. Share a document with another user or with a group A user can share a document with multiple users, including outside of the group (s) to which it belongs. From the \"Description\" tab: Click on the \"Share\" button Enter the name of the user with whom to share the document, or check his name in the list that appears To confirm, click on \"Share\" Share a document with a group or a user. 3.3.5.3 2.3. Share a template with another user or with a group A template is associated with a document and not with a user. To share a model with another user, there are two possibilities: Download the model from the Models tab and send the model via another exchange system (e-mails, etc.); Share with the user the document to which the template is associated. It is then up to the other user to download the model and then load it into the document where he wishes to apply it. "],["week-3-corpus-construction-and-computational-textual-analysis-in-islamicate-studies-1.html", "4 Week 3: Corpus Construction and Computational Textual Analysis in Islamicate Studies", " 4 Week 3: Corpus Construction and Computational Textual Analysis in Islamicate Studies 2/11/2021 Thursday Prepare for Class: Savant, Sarah Bowen. The History of Arabic books in the digital age. British Academy Review Summer 2016: 42-45. [Course Google Drive] Romanov, Maxim. Toward Abstract Models for Islamic History. In The Digital Humanities + Islamic Middle Eastern Studies, edited by Elias Muhanna, 117149. Berlin: De Gruyter, 2016. [Course Google Drive] Bulliet, Richard. Conversion to Islam in the Medieval Period. Cambridge: Harvard University Press, 1979, 1-32. Watch eScriptorium training video #2, Best Practices for Training Data Production. Upload and OCR a test text. In class: Weekly reading report. Collaboratory assignment on digital text production (bring your computers!). "],["week-4-corpus-construction-and-latest-approaches-to-computational-textual-analysis-i-1.html", "5 Week 4: Corpus Construction and Latest Approaches to Computational Textual Analysis I", " 5 Week 4: Corpus Construction and Latest Approaches to Computational Textual Analysis I 2/18/2021 Thursday This class was cancelled because of snow storms in Michigan. For the class of Feb 25, see the section on Week 5. Prepare for Class: Underwood, Ted. Distant Horizons: Digital Evidence and Literary Change. Chicago: University of Chicago Press, 2019. (selections). [Course Google Drive] Watch eScriptorium training video #3, Advanced Functionalities in eScriptorium. Watch eScriptorium training video #4, Data Export. Produce five pages of training data on your text and submit (after watching video #4). In class: Weekly reading report. Collaboratory assignment on digital text production (bring your computers!). "],["week-5-corpus-construction-and-latest-approaches-to-computational-textual-analysis-ii-1.html", "6 Week 5: Corpus Construction and Latest Approaches to Computational Textual Analysis II 6.1 Regular expressions 6.2 Installing EditPad Pro", " 6 Week 5: Corpus Construction and Latest Approaches to Computational Textual Analysis II 2/25/2021 Thursday Since we are still experiencing trouble with the eScriptorium instance on the UMD server, we will pause the eScriptorium tutorials until next week, and move material from the coming weeks forward. Prepare for Class: Regular Expressions tutorials #1-14: Regexone.com Install the free version of the text editor EditPad Pro: https://download.jgsoft.com/editpad/SetupEditPadProDemo.exe (for instructions, see below) Underwood, Ted. Distant Horizons: Digital Evidence and Literary Change. Chicago: University of Chicago Press, 2019. (selections). [Course Google Drive] Piper, Andrew. Enumerations: Data and Literary Study. Chicago: University of Chicago Press, 2018. (selections). [Course Google Drive] In class: Weekly reading report. Regular expressions exercises Introduction to using EditPad Pro. 6.1 Regular expressions Regular expressions is a formal language that can be used to describe patterns in strings (a string is a sequence of characters, what we humanists would loosely call text). Regular expressions are especially useful for creating complex search and replace operations. For example, there are many ways to transcribe the Arabic name Muammad in Latin script. The regular expression (or short, regex) M[uo]hammad matches both Muhammad and Mohammad: the square brackets tell the computer that between M and hammad we will accept a u or an o. The same device can be used to build a regex that can match many more transcriptions of Muammad: M[uo][h]am+[ae]d (here we used also the operator + to indicate that the letter m may appear one or more times). Regular expressions are easy to learn (the language uses only 14 special characters: .+*?^$()[]{}|\\), very useful for textual research and a good introduction to formal computer languages. A very good way to learn regular expressions is through the short regex tutorial at Regexone.com. Please go through lessons 1-14 (last lesson: Its all conditional) to prepare for class. We will do some exercises in class, so please come prepared! NB: each lesson takes only 2-3 minutes, and contains a short introduction and an elucidating exercise. You should be able to complete the tutorial in about 30-40 minutes (20 if you have already some experience with regular expressions). 6.1.1 Useful resources regular-expressions.info: detailed tutorial for regular expressions, with a lot of background, by one of the regex gurus, Jan Goyvaerts rexegg.com cheatsheet: a list of all special characters and devices used in regular expressions, with examples. Using this is not cheating! 6.2 Installing EditPad Pro For dealing with digitized text in Islamicate languages, we need a text editor that can handle right-to-left languages well, and can deal with the sometimes very large texts in the pre-modern written tradition. Our text editor of choice is EditPad Pro, which in addition to the two characteristics above, has a number of other powerful features that are very useful for searching, annotating and analyzing texts. One of the most useful features is that you can develop your own highlighting schema for your texts; for texts in the OpenITI corpus, for example, we have developed a schema that highlights the different levels of sections in a different colour, allowing the reader to easily navigate the text. The texts can also be folded to show only those headers, creating a table of contents. You can download the free version of the software (EditPad Pro 8) here: https://download.jgsoft.com/editpad/SetupEditPadProDemo.exe. This is a trial version, but is fully functional for our needs. NB: EditPad Pro works on Windows only. If you use a Mac or Linux computer, you can still run the program using an emulator software like Wine (whinehq.org), which makes it possible to use Windows programs on Mac and Linux. For Mac, see: https://wiki.winehq.org/MacOS. Alternatively, you can install a virtual machine on your computer that runs Windows: Parallels (commercial): https://www.parallels.com/products/desktop/ VirtualBox (free): https://www.virtualbox.org/ 6.2.1 Installing the OpenITI highlighting schema Once you have downloaded and installed EditPad Pro, take the following steps to install the OpenITI mARkdown schema (see https://github.com/OpenITI/mARkdown_scheme for more detail): VERY IMPORTANT: Make sure that EditPad Pro is fully closed. Do not close it using the X in the upper right corner (which will not fully close the program) but go to file &gt; exit in Edit Pad Pro. Download the schema from here Unzip the downloaded file. Open the unzipped folder, and copy all of the files in it Within the unzipped folder, double click on the link __Follow_this_link_to_paste_mARkdownScheme8.lnk. This link takes you to the location where EditPad Pro was installed on your computer (%APPDATA%\\JGsoft\\EditPad Pro 8) Paste the files into this folder Now, open EditPadPro. If you have done everything correctly, the background in EditPadPro should be of yellowish color. If the background is still white, you need to repeat the whole procedure; now, make absolutely sure to shut down EditPadPro (not just click on the x in the top right corner, but shut it down through FILE &gt; Exit), then repeat all steps from the beginning of this section. Try opening an OpenITI file to see the highlighing scheme in action. E.g., download the OpenITI/Shamela version of al-Iakhrs Kitb al-Mamlik wa-al-mamlik from here by right-clicking on the file 0346Istakhri.MasalikWaMamalik.Shamela0011680-ara1.mARkdown, and choosing Save link as; then open the saved document in EditPad Pro. NB: in a previous version of this course, the link led to a corrupted file "],["week-6-interacting-with-the-openiti-corpus-using-github-and-kate.html", "7 week 6: Interacting with the OpenITI Corpus Using Github and Kate", " 7 week 6: Interacting with the OpenITI Corpus Using Github and Kate 3/4/2021 Thursday Prepare for Class: Install some software we will need: Install Kate editor and the OpenITImARkdown highlighting scheme for Kate (instructions for Mac and Windows here) NB: Since our favourite editor EditPad Pro is not supported anymore on the most recent Mac operation systems, we have decided to use another free editor for use in the course that works for Mac, Windows and Linux users alike. So please install Kate, even if you are a Windows user and have already installed EditPad Pro last week. This will make tutorials much easier Install Git and Git Bash (instructions for Mac and Windows here) Create a GitHub account if you dont have it already: go to GitHub.com and sign up for an account (its free) Complete the very basic tutorial on using GitHub here. NB: to learn anything from a tutorial, you have to do all the steps yourself, not just read it! Also, type the commands yourself, do not simply copy them, you will learn much faster this way. Read a couple of introductory articles that will give you some very basic background on the tools we are going to use Introduction to the command line: read the first four sections of this tutorial: http://programminghistorian.org/lessons/intro-to-bash NB: (optional) A more detailed introduction (and useful list of commands) is available here: https://learnpythonthehardway.org/book/appendixa.html Very first introduction to using Github: https://guides.github.com/activities/hello-world/ Introduction to using Github from command line: https://towardsdatascience.com/getting-started-with-git-and-github-6fcd0f2d4ac6 In class: Introducing the OpenITI corpus Downloading OpenITI texts annotating texts using the OpenITI mARkdown scheme in Kate editor Using GitHub for cooperative project work "],["week-7-advanced-escriptorium-functionality.html", "8 week 7: Advanced eScriptorium functionality", " 8 week 7: Advanced eScriptorium functionality 3/11/2021 Thursday For class on Thursday, we are going to do two things: An activity on more advanced eScriptorium functionality. Jonathan will be posting the training videos for this in the next day or two. Please review these before class, and then in class you will work with him on a guided in-class activity on advanced functionality in eScriptorium. We are going to do all of the the reading report assignments in this weeks class. For this, we are going to ask you to form small groups of 2-3 students and select an article from the Cultural Analytics journal to present to class (please see the syllabus on the Reading Report assignmentthe summary: provide a basic summary of an article to the class in 10-12 min or sonothing too complex). You can use this listserv to coordinate groups. My suggestion would be for each of you to quickly review the CA archives (they arent big) and list a few articles that you would be interested in forming a group around. Others then can express their interest in joining forces with you to co-present one of the articles. Groups can be 2 or 3 people. (Alternatively, if you have another distant reading article from another journal that you really want to read and present, you can send that along to us and we will approve it if it looks good.) This will knock out two birds with one stone (such a violent and distressing phrase, no?). We will get everyones reading reports done and you will get a chance to see more applications of computational approaches before we dive into R. 3/14/2021 - 3/21/2021: UMD Spring Break (No class) "],["week-8-introducing-r-in-gui-through-stylometry-1.html", "9 week 8: Introducing R (in GUI) through Stylo(metry)", " 9 week 8: Introducing R (in GUI) through Stylo(metry) 3/25/2021 Thursday Prepare for Class: Holmes, David I. The Evolution of Stylometry in Humanities Scholarship. Literary &amp; Linguistic Computing 13, no. 3 (1998): 111-117. [Course Google Drive] Koppel, M., Schler, J. and Argamon, S. Computational Methods in Authorship Attribution. Journal of the American Society for Information Science and Technology 60, no. 1 (2009): 9-26. [Course Google Drive] Eder, Maciej, Jan Rybicki, and Mike Kestemont. Stylometry with RA Package for Computational Text Analysis. The R Journal Vol. 8/1 (2016). [Course Google Drive] Eder, Maciej, and Jan Rybicki. STYLO R Script Mini HOW TO. [Course Google Drive] Optional (extra credit for UMD students): Sadeghi, Behnam. The Chronology of the Qurn: A Stylometric Research Program. Arabica 58.34 (2011): 210-99. [Course Google Drive] In class: Weekly reading report. Collaboratory assignment with Stylo R Package (bring your computers!). "],["week-9-r-bootcamp-i-1.html", "10 week 9: R Bootcamp I", " 10 week 9: R Bootcamp I 4/1/2021 Thursday Prepare for Class: Chapter 1-2 in Arnold and Tilton and Chapter 1 in Jockers (there will be some overlap). Submit Before Class: Practice exercises for chapter 2 in Arnold &amp; Tilton, pages 183-186 (Please submit your code (i.e., the R script file) and also any resulting visualizations (e.g., graphs, tables) or answers (in the form of a screenshot)). In class: Weekly Reading Report: Analyzing Text Reuse Data in R (Sarah Bowen Savant). Sheykh Google activity (bring your computers!). "],["week-10-r-bootcamp-ii-1.html", "11 week 10: R Bootcamp II", " 11 week 10: R Bootcamp II 4/8/2021 Thursday Prepare for Class: Chapter 3 in Arnold and Tilton. Submit Before Class: Practice exercises for chapter 3 in Arnold &amp; Tilton, pages 186-188. In class: Weekly Reading Report: Topic Modeling in R (Matthew Thomas Miller). First brainstorming session on final project topics. "],["week-11-r-bootcamp-iii-1.html", "12 week 11: R Bootcamp III", " 12 week 11: R Bootcamp III 4/15/2021 Thursday Prepare for Class: Chapter 4 in Arnold and Tilton. Submit Before Class: Practice exercises for chapter 4 in Arnold &amp; Tilton, pages 188-190. In class: Weekly Reading Report: Geolocation Analysis in R (Peter Verkinderen). Second brainstorming session on final project topics (by end of this class, we will set the text analysis groups and their respective assigned chapters for week 10 based your initial ideas for the final project). Research collaboratory groups finalized and first set of individualized assignments distributed in preparation for your research groups first research collaboratory. "],["week-12-research-collaboratory-i-1.html", "13 week 12: Research Collaboratory I", " 13 week 12: Research Collaboratory I 4/22/2021 Thursday: Research Collaboratory Prepare for Class: Task(s) assigned to you by your research group in previous collaboratory. In class: Research collaboratory focused on final project (bring your computers!). "],["week-13-research-collaboratory-ii-1.html", "14 week 13: Research Collaboratory II", " 14 week 13: Research Collaboratory II 4/29/2021 Thursday: Research Collaboratory Prepare for Class: Task(s) assigned to you by your research group in previous collaboratory. Submit Before Class: By todays class, all groups need to submit a final project proposal to the instructors. This proposal should include three parts: a 1-page overview of the topic on which you are proposing to work; a timeline for the completion of each phase of the work (which the instructors will need to approve); and a detailed list of tasks for which each group member will be responsible. After you have submitted these, the instructors will review them together and send you our feedback, recommendations, and expectations for your final project. In class: Research collaboratory focused on final project (bring your computers!). "],["week-14-research-collaboratory-iii-1.html", "15 week 14: Research Collaboratory III", " 15 week 14: Research Collaboratory III 5/6/2021 Thursday: Research Collaboratory Prepare for Class: Task(s) assigned to you by your research group in previous collaboratory. In class: Research collaboratory focused on final project (bring your computers!). "],["working-with-github.html", "16 Working with GitHub 16.1 Why use a version control system? 16.2 Installing Git 16.3 Introducing your main git tool: Git Bash 16.4 Absolute minimum knowledge of command line commands 16.5 Essential GitHub commands 16.6 Creating your first GitHub repository 16.7 Cloning: downloading a GitHub repository 16.8 Save your changes: add and commit 16.9 Publish your changes: push changes 16.10 Workflows for collaboration with Git 16.11 Solving merge conflicts 16.12 Further reading", " 16 Working with GitHub GitHub is primarily a software development platform but it is very useful as well for other projects that require intensive cooperation and/or version control. GitHub uses the distributed version-control system Git (https://en.wikipedia.org/wiki/Git) for keeping track of changes to files on each of the different developers machines. GitHub also offers additional features that facilitate collaboration within the core team, collaboration with outside contributors and interaction with users. 16.1 Why use a version control system? (adapted from https://swcarpentry.github.io/git-novice/01-basics/index.html ) Even if working alone, you quickly run into multiple versions of the same document. This problem is compounded when working in a team. Version control systems start with a base version of the document and then record changes you make each step of the way. You can think of it as a recording of your progress: you can rewind to start at the base document and play back each change you made, eventually arriving at your more recent version. Once you think of changes as separate from the document itself, you can then think about playing back different sets of changes on the base document, ultimately resulting in different versions of that document. For example, two users can make independent sets of changes on the same document. Unless multiple users make changes to the same section of the document - a conflict - you can incorporate two sets of changes into the same base document. A version control system is a tool that keeps track of these changes for us, effectively creating different versions of our files. It allows us to decide which changes will be made to the next version (each record of these changes is called a commit), and keeps useful metadata about them. The complete history of commits for a particular project and their metadata make up a repository. Repositories can be kept in sync across different computers, facilitating collaboration among different people. GitHub uses the version-control system Git (https://en.wikipedia.org/wiki/Git). Git is called a distributed version-control system because the change history of a repository is maintained not only on a central server, but also in each copy of the repository (we will see later that these changes are located in a folder called .git at the root of the repository). 16.2 Installing Git 16.2.1 On Windows (instructions from https://www.pluralsight.com/guides/using-git-and-github-on-windows) Download Git for windows here: https://gitforwindows.org/ Execute the downloaded file. A few notes on the options you will be given during the installation process: In the page Select Components you can leave the options at their defaults. The Windows Explorer integration &gt; Context menu entries option allows opening the Git command prompt (Git Bash) from any folder by clicking with the right mouse button on the folder and selecting Git Bash Here. The last option is also interesting in that it installs a better font for all console windows. On the next screen (Adjusting your path environment), choose the most conservative option: Use Git Bash only. This will make git commands available only in Git Bash and will not alter your PATH variable. Click Next. Another important setting: line endings. As you may know, Windows and Unix systems (Linux, Mac) have different formats of line breaks on text files. If you write a file with Windows line breaks, another person may have problems opening that file in Linux and vice-versa. The line endings setting allows you to normalize this. Choosing the second option (Checkout as-is, commit Unix-style line endings), that won't change the line breaks when the file arrives but will convert them to Unix-style when you commit. That way, you don't risk committing Windows-style line breaks and everything is kept in Unix-style. Don't worry, even though you are in Windows, most of the text editors can read Unix line breaks just fine. After that one more Next, Finish, and Git is installed! 16.2.2 On Mac (instructions from https://www.atlassian.com/git/tutorials/install-git) Download Git for Mac here: https://sourceforge.net/projects/git-osx-installer/files/ Follow the prompts to install Git. 16.2.3 On Linux (instructions from https://www.atlassian.com/git/tutorials/install-git#linux) From your shell, install Git using apt-get: $ sudo apt-get update $ sudo apt-get install git 16.3 Introducing your main git tool: Git Bash 16.3.1 On Windows We interact with Git through a program called Git Bash, which was installed together with Git in the step above. Git Bash is a command line program, which means you interact with it not by clicking buttons with your mouse but by writing commands. Only the thought of this may repulse many humanities scholars, but fear not: it is easy to learn, and we need only very few commands. To open Git Bash, right-click on a folder in Windows Explorer, and choose Git Bash here This will open the program: 16.3.2 On Mac If you are a Mac user, you are probably familiar with the standard Mac command line tool, Terminal. You can use Terminal to interact with Git, or install a dedicated command line tool for Git, called Git Bash: To open Terminal, do one of the following: Click the Launchpad icon in the Dock, type Terminal in the search field, then click Terminal. In the Finder , open the /Applications/Utilities folder, then double-click Terminal. To install Git Bash: download it from here: https://downloads.digitaltrends.com/git/mac 16.3.3 On Linux If youre using Linux, you dont have to download the Git Bash program; you can use the normal terminal to interact with Git. To launch the shell, use the keyboard shortcut Ctrl-Alt-T. You can use all normal Linux commands (cd, ls, ), in addition to a number of additional git commands that will be explained below. 16.4 Absolute minimum knowledge of command line commands NB: to learn anything from a tutorial, you have to do all the steps yourself, not just read it! Also, type the commands yourself, do not simply copy them, you will learn much faster this way. There are basically two main ways to interact with a computer. The one you are probably most familiar with, is through a graphical user interface (GUI), in which different programs are represented by graphical icons, on which you can click with your mouse to open them - that is, the way we usually interact with a computer. The other way is through a command-line interface (CLI), which uses only text to interact with a computer: instead of clicking on different icons on the screen with a mouse to tell the computer what to do, you use the keyboard to write the commands to the computer directly. Even though most modern computers mainly use a graphical user interface (GUI), each also has a program that allows you to interact with the computer through text commands. Such a program is known by many names: terminal, command line, command prompt, shell. To interact with GitHub, we will use such a command-line interface: on Windows, you can use Git Bash; on Mac, you can use Terminal (or Git Bash); and on Linux the standard Linux terminal. For instructions on how to install/open these, see the previous section. In this tutorial, we will be using Git Bash. If you use a different program, it might look slightly different, but it should still be recognizable, and the commands you have to enter are the same. Open the command line shell of your choice. this is what it should look like: basically, a black (or white) window, with some text at the top. GitBash on Windows MacOS BigSur Terminal Linux Ubuntu terminal The displayed text on your machine will be different than in the image here: it contains: basic information on your computer and the user who is logged in: &lt;user&gt;@&lt;system&gt; (in the images above: peter@Desktop-sRKSSV6, bigsur@Andrews-MacBook-Pro, mark@linux-desktop) information on your location in your computer system (in the images above: /d/London/trainings/GitHub, ~ and ~ ; ~ refers to the home directory on Mac and Linux computers) the prompt: a symbol that shows that the shell is ready to accept your commands (in the images above: $, % and $; the exact symbol differs depending on the program and/or the user account type (normal user, administrator) that is logged in) the cursor: a blinking bar or rectangle that shows the position where a character will appear when you hit a key on your keyboard. NB: this whole line (in the Windows example, two lines) is usually called the command prompt, or simply prompt. IMPORTANT In this tutorial, we will include the dollar sign before every line that should be executed in Git Bash; you dont have to write it in Git Bash when copying commands from this tutorial. Write your first command: type pwd, which means print working directory: $ pwd (remember not to type the prompt symbol $!) Press the Enter key to execute the command. A line that contains the path to your current folder will appear, and beneath it, a new command prompt: NB: to know what this path means, please go on to read the next section. In general, you will always have to hit enter to execute a command, and any output from the command will be printed to the line(s) below the line on which you wrote your command. When the computer is ready executing your command, a new prompt will appear, signalling that it is ready to execute a new command. 16.4.1 The filesystem: an introduction Each computer has a system to organize all the files in it; this is called its filesystem. Files are usually kept in logical groups, which are called directories or folders - think of the cardboard folders in which you store paper files. A physical library is organized in a way that facilitates retrieving a book: this makes it easy for a user to go and fetch a book if she knows it is stored in room 2.03 on the second floor of the building, in book case number 8, on the third shelf. The filesystem in a computer is organized in a similar hierarchical way. Each file is contained in a directory, which is itself contained in another directory (called its parent), and so on until it reaches the root directory, which contains all other directories. The image is that of a tree, where each directory is a branch, and each file a leaf. There is a unique path that describes the way from the root directory to any directory or file in the filesystem. The shell knows in which directory it is currently located; this is called its working directory. Any command you write in the shell will be executed in the shells current directory; for example, if you write a command to create a new file (the command to do create a file called my_file.txt touch my_file.txt), this file will be created in the current working directory. The pwd command shows the path to that directory from the root directory. In the example above, the root directory is symbolized by the first forward slash /; the following slashes in the path delineate directory names. The GitHub folder is located within a directory called trainings, which in turn is located in a folder called London, which in turn is located in the d directory in the root folder of my computer. The path /d/London/trainings/GitHub tells the computer it can find the GitHub folder by opening the d directory in the root folder, then the London folder in the d directory, then trainings folder inside that London folder. 16.4.2 Moving from one directory to another: the cd command We can use the command cd (for change directory) to move to another folder. For this first exercise, we are going to move from our current working directory to the root folder, and then move our way back up to the original working directory. First use the command pwd to print your current working directory, so that we know the full path to our current working directory and can get back to it later: $ pwd /d/London/trainings/GitHub (again, dont include the $ symbol in your command - it symbolizes the prompt!) NB: the output on your computer will of course be different, as it depends on the file structure on your computer and your current location within it! To move to the root folder, you can use this command: $ cd / if you enter the pwd command again, it will now show only the forward slash that symbolises the root directory: $ pwd / The working directory is also reflected in the prompt itself: (the exact way how this is represented in the prompt will differ from system to system) Lets start moving back in the direction of our original working folder (in my case, /d/London/trainings/GitHub; in your case, the path that was printed in step 1). Lets go step by step: first write cd, followed by a space, followed by the first directory in the path (in my case, d) - you may choose to include the slash after the directory name or not; press the Enter key. Repeat for the next directory: cd + the next directory in the path (in my case, London), and Enter: You can also take larger steps, by stringing directories together with forward slashes, as in the path we printed with the pwd command. Since we are currently in the London folder, we can write the following command to reach the GitHub folder: To move to the parent folder (that is, the folder that contains the current working directory, the folder immediately before the working directory in the path): use the command cd ..: 16.4.3 More navigation in the command line: the ls command To list all files and folders in the current working directory, use the command ls (for list). This will display all files and folders in the current working directory. You can use this information to move into one of these folders. You can also list the contents of another directory than the working directory, by adding the path to that directory after ls. For example, if we want to list the contents of the GitHub folder while we are in the trainings folder, we can write: NB: note that Git Bash displays folders in blue (followed by a forward slash), and files in white. Note also the quotation marks around the file name; they are there because the file name contains a space. If any folder or file name in a path contains a space, you will have to use quotation marks around it. Similarly, we can list the contents of the root folder from anywhere in the filesystem tree (in this example, again from the trainings folder):  Or use the full path to any folder: 16.4.4 Using autocomplete Most (all?) command line programs provide an autocomplete functionality. You can write part of a folder or file name and press the Tab key on your keyboard, and the program will try to complete the folder/file name. For an example, I will cd into the root directory (cd /). If we want to return to the GitHub folder, we can type cd d/Lon, and hit Tab; the program will autocomplete to cd d/London/, because there is no other file or folder in the directory d that starts with Lon. We can then continue typing trai, and hit Tab again to autocomplete to cd d/London/trainings. I can then type Gi followed by Tab to autocomplete to cd d/London/trainings/GitHub. 16.5 Essential GitHub commands We will be covering the following commands during this tutorial: git clone git status git add git commit git push git pull git remote add These few commands will be enough to do most of your work on GitHub. Thats not too bad, is it? 16.6 Creating your first GitHub repository A repository is a folder that contains a git project. You will create a repository for each project you are starting. Go to GitHub.com. If you dont have a GitHub account yet, create one now by clicking the sign up button and go through the sign up process. To finalize the process, you have to click a link sent to the email address you used to set up the GitHub account Log in to your account by clicking the Sign in button in the top right of the window. Once youre signed in, youll see an automatically created personal avatar in the top right of the window;if you click on it, youll see your user name and a couple of links: Create a repository by clicking the plus sign next to your avatar, and selecting New repository from the dropdown list: Give your repository a new name. It is a tradition in computer programming to call your first project Hello World. GitHub does not allow spaces in repository names, so lets call ours HelloWorld. Also add a short description. GitHub gives you a couple of additional options: the repository can be either public (meaning, anyone on the internet can see it, but you can decide who can make changes to it) or private (meaning it is invisible, but you can invite specific people to view your repo and participate in it). GitHub also offers you to create your repository with some files included from the start: a README file explaining what this project is about, a .gitignore file (which describes which files should never be copied when downloading and uploading to GitHub - more on this later), and a license (which describes how people can use your project - copyright-wise). Lets create the repository without any of these files, and click the green Create Repository button. When the repository is created, you arrive at a landing page, which explains very shortly what the next steps could be: manually create a new file in the repository upload an existing file to the repository connect your new repository to a folder on your local computer use the command line to add data from an existing folder on your local machine to this git repository import code from another repository Well use the first option and create a README file: click the creating a new file link in the Quick setup section of the landing page: Give a name to the file: well call it README.md: NB: .md is the extension for markdown files. Markdown is a lightweight markup language that allows you to format a text with title headings, bold, italics, etc. using a small amount of special characters. See a cheatsheet with an overview of the syntax elements here: https://www.markdownguide.org/cheat-sheet/. It is a very useful format for writing things for the internet - this tutorial was also written in markdown. Lets write some markdown text in the README.md file: If you click the Preview button, you can see the effect of the special characters # (first-level header), **...** (bold) and * (unordered list) is: At the bottom of the page (you may have to scroll down) you will find a message box titled Commit new file. Commit is an important git command: every change you make in a git repository will be saved with a short descriptive title (commit message) for later reference, so that other users (or yourself) can go through the history of changes and roll back changes if necessary. The commit message is usually a very short message (about 50 characters), in the imperative form. You can write it in the smallest of the two input fields. You will see that GitHub has already provided you with a proposal for your first commit message: Create README.md You can also add a more extensive description in the larger input field; this is optional. In order to save our changes, we have to click the green Commit new file button. Thats it, you have created your first GitHub repository with your first README file, and you made your first commit! If you want to edit the README.MD file, you can click the pencil icon: Dont forget to write a new commit message and click the Commit new file button if you have edited the text of the README file! You can see the history of our commits by clicking the History button under the green Code button: This will show you all changes (commits) in the repository, from newest to oldest: 16.7 Cloning: downloading a GitHub repository Now that we have created our first GitHub repository, lets download it to our personal computer, and make some more changes there. The process of downloading a repository from GitHub on your local computer is called cloning. Remember, every local copy of a git repository contains the entire history of the repository, and is thus effectively a clone of the repository. Go to the page of the repository you want to clone on GitHub, and click the green Code button. This will open a dropdown, which contains - among other things - a download link (usually, it will be the address of the GitHub page, with a .git extension appended to it). Click the clipboard icon next to that link to copy the link to your clipboard. Open the command line program you use for git (Git Bash, Terminal, Linux shell - see above for instructions) and navigate to the folder where you want to save a copy of our HelloWorld repo. I will save it in my d/London/trainings/GitHub folder; you will have to use the cd command with the path to a folder in your file system instead (see above for more info on the file system and paths and on the cd command) Write the following command: git clone and paste the link from the clipboard, and hit enter. In the case of the repo we created in the previous section, this would be $ git clone https://github.com/OpenITI-Training/HelloWorld.git NB: in Git Bash on Windows, you cannot use the normal shortcut for pasting (ctrl+v); use shift+insert (or right-click, and choose Paste) instead. The program will print a number of lines to the screen, detailing its progress: Congratulations, you cloned your first repository! Lets navigate into the folder, and lets see what is in there. Use the command cd HelloWorld to move into the HelloWorld folder, and then write the command ls -la to list all files in that folder (you already know the ls command; the characters -la at the end are so-called flags that change the behaviour of the command: -l tells the program to list some details about each element in the folder, and -a to include all files, including those that start with .). The last item is probably the only one you expected: the README.md file we created on the GitHub page. The first two items in the list refer to the current folder (.), and its parent folder, that is, the folder that contains the current folder (.., remember the cd .. command). The most important item in the list is the .git folder; this folder contains the entire history of the repository. 16.8 Save your changes: add and commit Now that we have cloned our GitHub repository, we can work with it: add new files and folders, make changes to existing files or delete them altogether. Whenever you have made a change to your local repo, you have to notify Git that you did so. It is the Git equivalent of using save as. Git stores changes you made under the form of files known as commits; each commit has a unique id number, and a label (commit message) that describes in about 50 characters what changed to the repository when this commit was made. This allows a user to go back in the history of the repository, for example to return to earlier versions of a file. Make a change in the README.md file, using Kate editor. Make sure to save and close the file after you finished changing it. NB: You can open Windows Explorer in the current directory from Git Bash using the following command: $ explorer . On Mac, use open . instead to open Finder in the current directory. In Git Bash on your computer, use the cd command to move into your local repository: $ cd d/London/trainings/HelloWorld NB: use the path to the folder where you stored your HelloWorld repo, which will be different from the one shown here! You can use the command git status to make Git check which files in your local repository have undergone changes: $ git status If no changes occurred, you will get the following message: On branch master Your branch is up to date with \\&#39;origin/master\\&#39;. nothing to commit, working tree clean If you have made changes, Git will return a list of the files that have been changed (or added/deleted): For this example, we have changed the README.md file. Git displays it in red to show that the changes to this file have not yet been stored in Git. We will now commit our changes to git, which will save them in the .git folder on our computer. A commit is like a box in which changes are saved. First you have to add the changes to the box using the git add command, followed by the path to the file you changed - in our case, simply: $ git add README.md If you use the git status command again, you will see that the file we changed is now displayed in green: the changes are in the commit box, ready to be committed to the storage system. Using the command git commit, we will commit our changes to the storage system. For later reference, we have to add a commit message: a label to the commit box, so to say, that should help other users to understand the changes you made to the file without having to compare both files. The commit message should be introduced with the flag -m (for message), and be placed between (single or double) quotation marks: This is equivalent to hitting the green Commit button on the GitHub website NB: a good commit message should be around 50 characters long, be descriptive, and in the imperative mood: the idea is that when you go through the history of changes made to a repo from the start, you can read the commit message as when you execute this commit, Git will Your changes have now been included in the change history. You can view the change history with the command git log: This gives you a list of all changes (commits) made to the repository, from the most recent to the oldest. As you can see, every commit has a unique 40-character ID that can be used to go back to the state of the repository when this commit was made. The log also lists the author and date of every commit, plus its commit message. NB: if the number of commits exceeds the Git Bash window, the log will open in an editor within Git Bash. You can use the UP and DOWN arrows on your keyboard to navigate through this history. To quit the log, type q after the colon at the bottom of the window. 16.9 Publish your changes: push changes Now you have committed your changes in your local Git repo, but if you go to your personal GitHub page, you will see that the changes you made in your local repository are not present there. The online repository on your GitHub page (your remote repository in Git-speak) is not automatically updated when you add and commit to your local repo. In order to update the remote repository, we will have to push our changes to GitHub. In Git Bash on your computer, use the cd command to move into your local repository if you were not in it already: $ cd D:/London/trainings/GitHub/HelloWorld Use the command git push origin main to push your changes to your fork on your personal GitHub page: $ git push origin main NB: origin is the default name for any remote repository you clone on your computer; main is the default name of main branch within that repository. So, this command means push the changes on the active branch of this repo on my local computer to the main branch of the remote repository it was cloned from (remote). You can see the name of the active branch in your repository in Git Bash: Branches are an important concept in Git (see here if you want to learn more), but are outside the scope of this tutorial. NB: main has become the default name for the main branch of a repository on GitHub only recently; in repositories created before October 2020, the default name was master. This change is the result of a backlash against the use of words with slavery connotations in computer science and engineering. If we go to our personal GitHub page now, we will see that our changes are now also visible in our remote repository. Our commit message is displayed at the top. 16.10 Workflows for collaboration with Git There are different ways how you can incorporate Git in team projects. We will describe two here that are relevant for us: * the centralized workflow, where there is one central repository to which all contributors push their changes; * and the forking workflow, where contributors cannot push changes directly to the central repository; each contributor to the project creates a copy (fork) of the central repository, and requests the maintainer of the central repository to pull their changes (pull request). Each of these has its advantages. 16.10.1 The centralized workflow 16.10.1.1 Adding collaborators to your personal repository The Git workflow described above (cloning a repo to your local machine and pushing back changes to GitHub) is useful when you use GitHub as a storage for your own personal projects. It can also be used for small team projects, such as the projects in this course, if the tasks are split clearly and chances are low that two persons will work on the same file at the same time. As mentioned above, you can give others write access to a repository you own - whether it is public or private. To do this, go to the Settings tab on the top of your repository (make sure you are logged in to your GitHub account): Click Manage access in the side bar: You may be prompted for your password; provide it if asked for it. Click the green Invite a collaborator button: Ask your collaborators GitHub usernames, and search for them in the search box; once you found them, click their user name. Finally, click the green button to add the collaborator to your repo: This person will now have the same rights as you have to push changes directly to the repository, just like you do. 16.10.1.2 Keeping up to date with the remote branch: git pull If more than one person is collaborating on a repository, it becomes very important that all versions of the repository are up to date. Every time before you start work on your local repository, make sure to synchronize it with the remote repository. In Git Bash, use the command git pull within your local repository to do this: $ git pull origin main This will fetch all the changes other contributors pushed to the repository and make sure your local repository is identical with the remote repository (origin). Similarly, every contributor will have to make sure that they push their changes to the remote repository regularly, to avoid that different clones of the repo drift apart. $ git push origin main NB: The git pull command is obviously the counterpart of the git push command; the imagery is of a box with changes being pulled from or pushed to another repository. pushing and pulling image adapted from https://img.17qq.com/images/phqfghghnky.jpeg 16.10.1.3 Overview of the git clone - pull - push workflow Cloning a repo from your personal GitHub page Keeping local and remote repo in synch: push and pull changes Collaborating on a personal repo: invite collaborators 16.10.2 An alternative workflow: forking and pull requests 16.10.2.1 introduction The GitHub workflow described above works well for personal projects and for small projects where all collaborators know each other and have clearly distinct tasks on which they work. However, in many projects, outside collaborators will not be given the right to directly push their changes to a repository: this would open the door to undesired or low-quality changes and even digital vandalism. An alternative workflow exists that is much safer and involves peer review of any change made by external collaborators. In this workflow, external collaborators create a copy (fork) of the repository on their own personal GitHub page, clone this fork to their local machine. When they have made their changes (and added and committed them to Git), they push their local changes to the remote fork on their own GitHub page, and request the owner of the original repo to review and accept their changes. In line with the push and pull imagery, this request is called a pull request: instead of pushing your changes to the original repo, you request that the owner of the repo pulls them in. pull, push, and pull request image adapted from https://img.17qq.com/images/phqfghghnky.jpeg NB: the term fork does not refer to the eating utensil but to the image of a fork in a river, the place where a large branch splits off from the main branch of the river: Fork of the Nile near Cairo If a repository is popular, it will not look like the Nile but like the Upper Columbia river, with many forks taking off and rejoining at a later point: Forks in the Upper Columbia river 16.10.2.2 The forking and pull requests workflow You can create a personal copy of any (public) repository on GitHub if you have a personal GitHub account. In this tutorial, we will create a fork of this repo: https://github.com/OpenITI-Training/ForkingExample Go to the repos page on GitHub and click the Fork button in the top right corner to create a copy of this repository on your personal GitHub account. If you look at the adress bar in your browser, and the title of the repository, you will see that you have now moved into a copy of the repository on your own GitHub page Make some changes to your fork of the repo; for this tutorial, we will add a text file to the fork. We are going to use the Add file &gt; Upload files function on GitHub itself: GitHub will offer you the possibility to drag and drop a file, or choose them from a file selection box.After adding the files, provide a commit message and hit the green Commit changes button. Create a pull request to send your file to the original (upstream) repository: click the Pull requests button under the name of the fork repository on your personal GitHub page: This will bring you to a new page, where you can compare changes between different forks of the original repository. To create a pull request, make sure your fork is in the head repository field, and the original repository from which you forked in the base repository - the arrow shows the way the data will flow. Then click the green Create pull request button. Provide a title and description for your pull request and click the green Create pull request button. The owner of the repo you cloned will be informed by email that you have made a pull request. They will review the changes you made; if they are happy to integrate them, they will merge you changes into the repository. They may also choose to comment on your changes and ask you to amend them before they will accept them. The Pull request is not only a security measure, but also an important communication channel on GitHub. 16.10.2.3 The forking and pull requests workflow in more detail In the previous section we took a shortcut in order to provide a quick introduction to the concepts of forking and pull requests: we uploaded a file to the fork on our GitHub page. In most cases, however, you will want to make changes on your local machine. In order to do this, we will have to clone the fork to our local machine, as we did in the centralized workflow (for details, see above). But to keep up to date with the original repository, we will have to create an additional direct link to that repository, so we can pull changes directly from that repo. Fork the repository to your own GitHub account: click the Fork button. Clone your personal fork to your local machine: copy the link displayed when you click the green Code button, and in Git Bash on your computer, enter the command git clone + the link. Move into the repository you cloned by using the cd command: Lets see the remote repositories connected to our local repo; will there already be a connection with the original repo? No: there is only a connection to the fork on our personal GitHub page. As you can see, this remote repository is called origin; this is the default name, created by Git when you use the command git clone. It is mentioned twice, because we are allowed to push to and pull (fetch) from our own remote repository. Create a connection with the original repo: go to the GitHub page of that repo, get the link to that repo by clicking the green Code button. Now go back to Git Bash and enter the command git remote add upstream, followed by the link to the original repository: NB: upstream is the name we give to the original repository; you can give it any other name if you like, but it is common to call it upstream, so better to stick with the traditions. upstream uses the same river imagery as fork. If we use the command git remote -v again, we will see that a new remote connection has been added to our local repository: NB: note that upstream is mentioned twice in the list, once for fetch and once for push. However, if you would try to push to the upstream repo, you would get an error message. This is because Git does not restrict you from pushing to that repository, it is GitHub that restricts push access. Before making any changes, it is a good idea to pull any new changes other users of the original repo (upstream) may have made in the meantime. If nothing had changed, you will receive the message Already up to date: If, however, changes have been made to the upstream repo since you forked it, or since you last synched your local repo with the upstream repo, Git Bash will download and list the changes that have been made in the upstream repo: It will then display a notification that the main branch of the repository will be merged into the main branch of your local repository. This message will be shown in an editor inside Git Bash; you can adapt the message if you wish, but it is usually fine to keep the default message and simply close the editor with the key combination Ctrl and X. The editor will ask whether it has to save your changes; write Y and hit the Enter key. Hit Enter again to confirm Git may store this file at the proposed location. NB: the merging of the two branches is stored in a commit; the message in the editor will function as its commit message. NB: if you have made changes to a file on your own computer, and someone else has meanwhile made changes in the upstream repo to the same line in that same file, this leads to a merge conflict: Git cannot decide which change to keep. You will have to resolve this merge conflict by manually selecting which changes to keep: the one you pulled from the OpenITI GitHub page, or the one you made locally. This can be a huge pain. In order to avoid this, always make sure to pull the changes from the upstream repository before you make any change to your local files! Now lets make some changes to our local repository. We will create a new (empty) file in this example that has our initials as its filename. You can do that by using the command touch, followed by the filename: If you type the command ls to list the content of the working directory, you will see that it now contains a file with that filename. Lets now commit our changes to Git using the commands git add and git commit -m: After committing your changes, and before pushing them to GitHub, it is good practice to pull changes from the upstream repo again (see above): Lets try to push our changes directly to the upstream repo - we already know this is not going to work, but lets try anyway to see the error message: Git tried to push our commit to the server, but GitHub denied us access. We have to take the detour of the pull request to publish our changes to the original repository. First, we push our changes to the remote repository (origin) on our personal GitHub page: Now we can create the pull request as we have done before: push the Pull requests button under the name of your fork on GitHub: This will bring you to a new page, where you can compare changes between different forks of the original repository. To create a pull request, make sure your fork is in the head repository field, and the original repository from which you forked in the base repository - the arrow shows the way the data will flow. Then click the green Create pull request button. Provide a title and description for your pull request and click the green Create pull request button. The owner of the repo you cloned will be informed by email that you have made a pull request. They will review the changes you made; if they are happy to integrate them, they will merge you changes into the repository. They may also choose to comment on your changes and ask you to amend them before they will accept them. The Pull request is not only a security measure, but also an important communication channel on GitHub. 16.10.2.4 Overview of the Forking workflow: The following images are a graphical representation of the Forking workflow, illustrated by an example drawn from the OpenITI corpus. Setting up your repositories for the Fork workflow The full workflow in one image 16.10.3 Comparison of both workflows push access forking - pull requests changes immediately reflected in remote repo changes only accepted after review no quality control quality control through review process less overhead: give permission only once every change must be reviewed Both workflows can be combined. For example, in the OpenITI project, the core technical team has such push access to most of the projects repositories, but external contributors have to fork a repo and make pull requests when they want to contribute texts or metadata to a repo. Thus, the positive aspects of both workflows can be used. 16.11 Solving merge conflicts As we have seen before, Git tries to merge changes you make in your local repo to the current state of the remote repo you push your changes to, and vice versa. It is quite smart at doing this; it takes into account at which time each change was made. However, there are cases in which Git cannot know how to merge two versions of the same file: usually, this happens when two users made different changes to the same line of text in the same file. This is called a merge conflict: Git does not know which of the changes is better, and it will let you decide which change to keep, and which one to discard. To simulate this, lets use our HelloWorld repo, and make changes to the same line in our local repo and in the remote repo (origin). In the repository on GitHub, click the pencil icon at the top of the README.md document: Make a small change to the first line of the description. E.g., replace our training with the OpenITI training. Write a commit message in the Commit changes box at the bottom of the screen and hit the Commit changes button. Now, lets make another change in the README.md file of the clone of this repository we made on our local machine. Open the document in your favourite editor, and make another small change to the same line: e.g., replace our training with the KITAB training. Add and commit the file in your local repo: Now pull the changes from the remote repo (origin) to your local repo: There you have it, a merge conflict The error message tells you - kind of - what is going on and what you have to do: Automatic merge failed; fix conflicts and then commit the result. NB: notice that the branch indication at the end of the prompt line has changed from main to main|MERGING: this is a temporary branch. To fix a merge conflict, open the file for which Git found a merge conflict - in our case, README.md in any text editor (e.g., EditPad Pro, Kate). You will notice something strange is going on in the file: Git has inserted a number of weird characters into our text file. In fact, these characters show us where the merge conflict is located in the text file, and the variants in the two conflicting commits: &lt;&lt;&lt;&lt;&lt;&lt;&lt; indicates the beginning of the merge conflict, and &gt;&gt;&gt;&gt;&gt;&gt;&gt; its end. Both are followed by a commit ID (commit IDs are usually 40-digit hexadecimal numbers; HEAD is an abbreviation for the commit ID that is currently checked out, that is, the ID of the current state of the files in your working directory) ======= separates both versions of the conflicting line(s) In order to fix the merge conflict, we can either delete one of the variants, create a combination of both, or replace them by an entirely different string. For this example, we will keep one version, the one from our GitHub repo. Remove the other version and all merge conflict markers and then save the file: NB: make sure to remove all the traces of the merge conflict markers! It is a good idea to use the search function of your editor to search for repetitions of &gt;, &lt; and = to check if you have not overlooked any. After fixing all merge conflicts in all files Git had trouble merging, we have to create a commit that records that we have solved all merge conflicts. If we first enter the command git status, we can see that Git is not yet informed that we have solved the merge conflict. Lets add and commit the README.md file: Running the git status command again after adding and committing the README.md file, we can see the merge conflict is now resolved: gone is the message both modified: README.md, and the branch indication in the prompt line went back to (main) from (main|MERGING). To finalize, we should push our changes back to our remote repository (origin): The message printed after our command git push origin main may be cryptic, but it shows no sign of a merge conflict. 16.12 Further reading This was only a very basic introduction to Git. There are many good resources around. Very first introduction to using Github: https://guides.github.com/activities/hello-world/ Introduction to using Github from command line: https://towardsdatascience.com/getting-started-with-git-and-github-6fcd0f2d4ac6 A more technical insight into the guts of Git: http://ftp.newartisans.com/pub/git.from.bottom.up.pdf on different workflows using Git: see https://www.atlassian.com/git/tutorials/comparing-workflows "],["kate-tutorial.html", "17 Kate Tutorial 17.1 Installing Kate editor 17.2 Installing the OpenITI mARkdown highlighting scheme for Kate 17.3 Working with Kate", " 17 Kate Tutorial Kate is a free text editor that can be used on Windows, Mac and Linux alike. It has good support for right-to-left scripts, handles large files reasonably well, and allows the creation of custom highlighting and folding schemes (for instructions for installing the OpenITImARkdown scheme, see below). This tutorial showcases only the most relevant functions of Kate for our purposes; for more information, please refer to the Kate Handbook, which can also be accessed through the Help menu in the program itself. 17.1 Installing Kate editor 17.1.1 On Windows Download the most recent installation file here: https://binary-factory.kde.org/view/Windows%2064-bit/job/Kate_Release_win64/ ; go to the Pipeline Kate_Release_win64 section on that page and download the file that ends with _64-cl.exe. Once the file was downloaded, double-click the installation file and follow the instructions (you can keep all the default settings the installer proposes) Kate should now be installed on your computer. Proceed to install the OpenITImARkdown highlighting scheme (see below) 17.1.2 on Mac Download the .dmg file here: https://binary-factory.kde.org/view/MacOS/job/Kate_Release_macos/ (choose the file that ends with .dmg, the other file is a checksum) Once downloaded click on the .dmg file, double click on the kate icon or drag it to the Applications folder NB: You will most likely get a message like kate cant be opened because Apple cannot check it for malicious software. This software needs to be updated. Contact the developer for more information. This is because recent Mac instances do not allow you to install apps from non-verified developers. There is however a way to override this security measure: Go to system preferences =&gt; security &amp; privacy =&gt; under general you will see a note saying \"Kate\" was blocked from use because it is not from an identified developer click open anyway a new pop up will appear where you will have to consent again, and then the app should launch The process is generally explained here (+ a shortcut if youre feeling adventurous): https://mac-how-to.gadgethacks.com/how-to/open-third-party-apps-from-unidentified-developers-macos-0158095/ Kate should now be installed on your computer. Proceed to install the OpenITImARkdown highlighting scheme (see below). 17.2 Installing the OpenITI mARkdown highlighting scheme for Kate 17.2.1 On Windows: Download the highlighting scheme OpenITImARkdown.xml file by right-clicking on this link and choosing Save link as. In Windows Explorer, go to C:/Users and double-click the folder with your user name In your user folder, find the folder AppData. This folder is sometimes hidden; to make it visible, you may have to go to the View tab in Windows Explorer, and check the box next to Hidden items: make hidden files visible Enter the AppData folder, double-click the Local folder, and make a new directory in it: org.kde.syntax-highlighting Within the new org.kde.syntax-highlighting folder, create another new folder: syntax. The full path to this folder should now be C:\\Users\\&lt;user_name&gt;\\AppData\\Local\\org.kde.syntax-highlighting\\syntax Copy the OpenITImARkdown.xml file into the newly created syntax folder. Close the Kate editor if it was open, and open it again. You should now be able to find the OpenITImARkdown highlighting scheme in the list in the Tools &gt; Highlighting &gt; Markup menu: OpenITImARkdown in Tools menu And also in the dropdown menu in the bottom right of your Kate screen: OpenITImARkdown in dropdown menu 17.2.2 On Mac: (Thanks to John for figuring this out!) Download the highlighting scheme OpenITImARkdown.xml file by right-clicking on this link and choosing Save link as. Open Terminal (see https://www.idownloadblog.com/2019/04/19/ways-open-terminal-mac/) Create new subdirectories in the ~/Library/Application Support folder by executing this command: mkdir -p &quot;$HOME/Library/Application Support/org.kde.syntax-highlighting/syntax&quot; NB: the quotation marks are essential because there is a space in the path! Assuming the OpenITImARkdown.xml file is in the Downloads folder: execute the following command to copy it to the newly created folder: cp ~/Downloads/OpenITImARkdown.xml &quot;$HOME/Library/Application Support/org.kde.syntax-highlighting/syntax&quot; Alternatively: Open Finder in the Finder menu, choose Go &gt; Go to folder..., write ~/Library/Application Support/, then click Go create a new folder using the combination command+shift+n, and call it org.kde.syntax-highlighting Move into that folder, and create another subfolder using command+shift+n, called syntax Copy the OpenITImARkdown.xml file into that folder Close the Kate editor if it was open, and open it again. You should now be able to find the OpenITImARkdown highlighting scheme in the list in the Tools &gt; Highlighting &gt; Markup menu: OpenITImARkdown in Tools menu And also in the dropdown menu in the bottom right of your Kate screen: OpenITImARkdown in dropdown menu 17.3 Working with Kate 17.3.1 Activating the OpenITI mARkdown highlighting scheme If you have correctly installed the highlighting scheme, texts that have the extensions .mARkdown, .completed or .inProgress should automatically activate the highlighting scheme. You can see the active highlighting scheme in the dropdown box at the bottom right of the screen: OpenITImARkdown in dropdown menu If this does not say OpenITImARkdown, click the button, write OpenITI and select the OpenITImARkdown. NB: there is also a markdown highlighting scheme in the list; this is designed for the markdown language on which OpenITI mARkdown is loosely based, but will not highlight OpenITI mARkdown text correctly. Alternatively, you can select the OpenITImARkdown highlighting scheme in the list in the Tools &gt; Highlighting &gt; Markup menu: OpenITImARkdown in Tools menu 17.3.2 Folding sections One of the most useful features of Kate and OpenITI mARkdown is that it allows you to fold all sections, displaying only their headers. In the menu, go to View &gt; Code Folding &gt; Fold Toplevel Nodes to collapse all sections, and View &gt; Code Folding &gt; Unfold Toplevel Nodes to make them visible in their entirety again. You can also use the following key combinations: Ctrl Shift - for folding Ctrl Shift + for unfolding NB: In a large text, it may take a second or two for the folding to take effect. You can also use the triangles next to the line numbers in the text to fold/unfold a single section: 17.3.3 Search and replace Kate contains three options for searching and replacing: the Search bar: simple search in the current document the Power Search and Replace bar: regex search and replace in the current document the Search in Files bar: regex search and replace in multiple documents at the same time The latter option is the most powerful, and displays all matched lines. 17.3.3.1 Search bar To make the Search and replace bar visible, go to Edit &gt; Find: You can also use the Ctrl+F key shortcut. This opens up a basic search bar, in which you cannot use regular expressions: * The Aa button toggles case sensitivity on and off. You can close the search bar by clicking the button with x in a red circle at the left-hand side of the search bar. To use regular expressions, open the Power Search and Replace Bar by clicking the button with the sliders on the right of the search bar: 17.3.3.2 The Power Search and Replace bar To make the Search and replace bar visible, go to Edit &gt; Replace: You can also use the Ctrl+R key shortcut. This opens the Power search and replace bar at the bottom of the screen: Selected controls: With the Mode dropdown, you can select whether you want to use Regular Expressions or plain text search. The Aa button toggles case sensitivity on and off. You can close the Power Search and Replace bar by clicking the button with x in a red circle at the left-hand side of the search bar. Use the Replace button to replace only the current match; use Replace All to replace all matches in the document. If you hit the Find all button, the number of matches found in the document will be displayed. 17.3.3.3 The Search in Files bar This is Kates most powerful search and replace option. Open the Search in Files bar in one of three ways: * in the menu, choose Edit &gt; Search Files * use the shortcut key combination Ctrl+Alt+F * click the Search and Replace button in the bottom left of the screen: The Search in Files bar contains much more options than the other search bars: 1. {} button: toggle regular expressions on/off 2. Aa button: toggle case sensitivity on/off (default: case insensitive, abc will match abc, ABC, aBc, etc.) 3. You can define whether the search and replace operation is executed only in the current file, in all open files, in a folder, in a project, or in all open projects. 4. you can run multiple searches at the same time: open a new search tab with this button 5. use this button to show all search options. 6. When you conduct a search, the results will be displayed in the results pane: 7. You can expand and collapse the search results in each file using this button: You can check and uncheck results in the results pane; use the button Replace Checked to replace all checked results in the results pane. NB: for regex capture groups, Kate uses the \\1, \\2, etc. syntax (as in Python), not the $1, $2, etc. syntax (as in Perl and JavaScript): Replace a # tag on a new line followed by a number by a ### | tag 17.3.4 || Displaying the toolbar A tool bar can be displayed below Kates menu bar. Go to Settings &gt; Show Toolbar to display it. You can add buttons to the toolbar in the Settings &gt; Configure Toolbars. 17.3.5 || Change font and other settings Go to Settings &gt; Configure Kate to change the font, font size and other settings: "],["openiti-markdown.html", "18 OpenITI mARkdown 18.1 OpenITI mARkdown header 18.2 Structural text units 18.3 Semantic patterns 18.4 Further reading", " 18 OpenITI mARkdown OpenITI mARkdown is a lightweight markup language designed to add basic tagging in a quick and efficient way to text in right-to-left languages. Advantages: no conflicts between LTR tags and RTL text no pairs of closing and opening tags as in TEI XML: only single tags OpenITI mARkdown tags can be converted to TEI XML highlighting and folding schemes available for EditPad Pro and Kate editors. limited but expandable tag set Full documentation: alraqmiyyat.github.io/mARkdown/ 18.1 OpenITI mARkdown header Each OpenITI mARkdown file has a header that contains three elements: the so-called magic value ######OpenITI#, which activates the OpenITI mARkdown highlighting scheme in EditPad Pro. It should be on the first line of the file, followed by a line break Zero or more metadata fields, each on one line, and each introduced by the tag #META#. This header is meant for metadata salvaged from digital text files, and is not necessarily machine-readable. Machine-readable metadata to each text file is provided in a separate file, in the YAML format; this file has the same filename as the file it describes, and the file extension .yml. Header splitter #META#Header#End#: this tag, preceded and followed by an empty line, splits the metadata header off from the main body of the text. 18.2 Structural text units 18.2.1 Paragraphs #: The start of a paragraph in OpenITI texts is tagged with a single hashtag, followed by a space. ~~: because many text editors have trouble displaying very long lines of text, paragraphs in OpenITI texts are split into short lines (max. 72 characters), each preceded by two tildes. Paragraphs and page numbers, highlighted in Kate editor NB: in the near future, OpenITI mARkdown will abandon these tags and will mark paragraphs as done in standard markdown: double line breaks as paragraph dividers. 18.2.2 Page numbers: PageV##P### Page numbers in OpenITI mARkdown are formatted in the PageV##P### format; V## refers to the volume number, P### to the page number. Both are padded with zeroes (e.g., PageV01P001). manuscript transcriptions, add A to the page number for recto, and B for verso (e.g., PageV01P002B). 18.2.3 Section headers: ### |, ### ||, etc. Section header tags must always start on a new line and consist of two elements: three hashtags, followed by a space one or more pipe symbols (|), followed by a space. The number of pipes defines the level of a header: one pipe is level 1, two pipes is level 2, etc. The highlighting scheme will give each level a different colour. If the section has a title, put it on the same line immediately after the final space of the tag. If the title does not have a section, the rest of the line after the space may be left blank. Folded OpenITI mARkdown section headers in Kate editor 18.2.4 Dictionary units: ### $ Lemmata in texts that have a dictionary format (lexicographical dictionaries, biographical dictionaries, abaqt works, bibliographical works, etc.) can be tagged using the ### $ tag: ### $: simplified lemma tag: can be used if there is only one type of entry in a dictionary-type work, or as a temporary tag descriptive unit tags: the type of lemma can be expressed by putting it between two dollar signs: e.g., dictionary entries: ### $DIC_NIS$ [a descriptive name entry] ### $DIC_TOP$ [a toponym entry] ### $DIC_LEX$ [a lexical entry] ### $DIC_BIB$ [a book title] biographical dictionary entities: ### $BIO_MAN$ [a biography of a man] ### $BIO_WOM$ [a biography of a woman] ### $BIO_REF$ [a cross-reference, for both men and women] ### $BIO_NLI$ [a list of names] shorthand unit tags: if a book contains multiple types of lemmata (e.g., biographies of men and women; book titles and genre categories), multiple dollar signs can be used to differentiate between each type. E.g., ### $ [a biography of a man] ### $$ [a biography of a woman] ### $$$ [a cross-reference and/or repetition, for both men and women] ### $$$$ [a list of names] 18.2.5 Paratext sections: ### |EDITOR|, ### |PARATEXT|, ### |APPENDIX| These tags are used to mark sections that do not really form part of the text; for many kinds of computational analysis, it may be useful to disregard these sections: ### |EDITOR|: title pages and front matter of the printed editions, editorial introductions, indices, table of contents, etc. ### |PARATEXT|: scribal additions to the text, riwyas at the start of a text, sama statements,  ### |APPENDIX|: appendices to the text that are closely related to the text, e.g., known fragments from lost parts of a text, sections from alternative manuscript transmission chains, etc. All of these tags are put on their own on a new line of text at the beginning of the section. The section continues until the next ### tag, or the end of the text 18.2.6 Verses of poetry: # &lt;hemistich_1&gt; %~% &lt;hemistich_2 NB: make sure each verse starts on its own line. Poetry verses tagged in OpenITI mARkdown, highlighted in EditPad Pro 18.3 Semantic patterns 18.3.1 Years: YY####, YB####, YD####, YA#### Years mentioned in a text can be tagged by placing one of the following tags in front of them (separate them from the text with a space): YB####: year of birth YD####: year of death YA####: age in years YY####: any other type of year reference NB: these tags must be preceded and followed by a space. Years tagged in OpenITI mARkdown, as displayed by EditPad Pro 18.3.2 Named entities (toponyms, personal names, ): @XXX## This category of tags has a special structure: all tags consist of: an ampersand @ a three-letter code: TOP for toponyms SOC for biographical characteristics PER for persons SRC for sources (book titles, citation statements like qla fuln, ) QUR for Qur'n verses a digit that refers to the length of an attached prefix: e.g., @TOP01  @TOP11  @TOP21  one or more digits that refer to the number of tokens of the entity (The highlighting scheme will highlight this number of tokens after the tag): e.g., @TOP12   @SRC010           NB: in order to speed up your tagging, you may use variants of these same tags with a single-letter code: @T##, @S##, @P##, @Q## Named entities highlighting in EditPad Pro 18.4 Further reading Full documentation: alraqmiyyat.github.io/mARkdown/ "]]
